{-# OPTIONS --cubical --type-in-type #-}

open import Cubical.Foundations.Prelude
open import Cubical.Foundations.Function
open import Cubical.Foundations.Univalence
open import Cubical.Foundations.Transport
open import Cubical.Foundations.Isomorphism renaming (Iso to _‚âÖ_)
open import Cubical.Data.List hiding ([_])
open import Cubical.Data.List.Properties
open import Cubical.Data.List.FinData renaming (lookup to _!_)
open import Cubical.Data.List.Dependent renaming (lookupP to _!P_)
open import Cubical.Data.Prod
open import Cubical.Data.W.Indexed
open import Cubical.Data.FinData
open import Cubical.Data.Sum
open import Cubical.Data.Sum as ‚äé
open import Cubical.Data.Empty
open import Cubical.Data.Nat
open import Cubical.Data.Sigma.Properties
open import Cubical.Foundations.Structure
open import Cubical.Categories.Category
open import Cubical.Categories.Category.Precategory hiding (_[_,_] ; seq')
open import Cubical.Categories.Functor renaming (ùüô‚ü®_‚ü© to ftrId)
open import Cubical.Categories.Instances.Sets
open import Cubical.Categories.Instances.Categories
open import Cubical.Categories.Constructions.Product
open import Cubical.Categories.Monad.Base
open import Cubical.Categories.NaturalTransformation.Base
open import Cubical.Categories.Instances.FunctorAlgebras
open import Cubical.Categories.Instances.EilenbergMoore
open import Cubical.Categories.Adjoint
open import Cubical.Categories.Limits.Initial

open import Mat.Signature
open import Mat.Free.Presentation

-- TermQs of the free MAT generated by a free MAT presentation
module Mat.Free.Term {matsig : MatSignature} (fmat : FreeMat matsig) where

open _‚âÖ_
open Category renaming (_‚àò_ to _‚äö_)
open Functor
open NatTrans
open MatSignature matsig
open FreeMat fmat
open Algebra renaming (str to algStr)
open AlgebraHom
open IsEMAlgebra
open NaturalBijection
open _‚ä£_

-- Free syntax monad
data TermF (X : MType) : (sortOut : Sort) ‚Üí Type
isSetTermF : (msetX : MSet) (sortOut : Sort) ‚Üí isSet (TermF (mtyp msetX) sortOut)

-- TermF acting on MSets
msetTermF : MSet ‚Üí MSet
fst (msetTermF msetX sortOut) = TermF (mtyp msetX) sortOut
snd (msetTermF msetX sortOut) = isSetTermF msetX sortOut

data TermF X where
  varF : ‚àÄ {sortOut} ‚Üí X sortOut ‚Üí TermF X sortOut
  astF : ‚àÄ {sortOut} ‚Üí Term1 (TermF X) sortOut ‚Üí TermF X sortOut

pattern _$1_ o args = astF (term1 o args)

-- TermF is really an IW type
module _ where
  RepTermF : (X : MType) (sortOut : Sort) ‚Üí Type
  RepTermF X sortOut =
    IW (Œª sort ‚Üí X sort ‚äé Operation sort)
      (Œª sort ‚Üí ‚äé.elim (Œª v ‚Üí ‚ä•) Œª o ‚Üí Fin (length (arity o)))
      (Œª sort ‚Üí ‚äé.elim (Œª v ()) (Œª o p ‚Üí arity o ! p))
      sortOut

  {-# TERMINATING #-}
  toRepTermF : (X : MType) (sortOut : Sort) ‚Üí TermF X sortOut ‚Üí RepTermF X sortOut
  toRepTermF X sortOut (varF v) = node (inl v) (Œª ())
  toRepTermF X sortOut (astF (term1 o args)) = node (inr o) Œª p ‚Üí mapOverIdfun (toRepTermF X) (arity o) args !P p

  {-# TERMINATING #-}
  fromRepTermF : (X : MType) (sortOut : Sort) ‚Üí RepTermF X sortOut ‚Üí TermF X sortOut
  fromRepTermF X sortOut (node (inl v) u) = varF v
  fromRepTermF X sortOut (node (inr o) args) =
    astF (term1 o (mapOverIdfun (fromRepTermF X) (arity o) (tabulateOverLookup (arity o) args)))
    --Œª p ‚Üí fromRepTermF X (arity o ! p) (args p)

  {-# TERMINATING #-}
  fromToRepTermF : (X : MType) (sortOut : Sort) (t : TermF X sortOut)
    ‚Üí fromRepTermF X sortOut (toRepTermF X sortOut t) ‚â° t
  fromToRepTermF X sortOut (varF v) = refl
  fromToRepTermF X sortOut (astF (term1 o args)) =
    cong astF (cong (term1 o) (
      mapOverIdfun (fromRepTermF X) (arity o) (tabulateOverLookup (arity o) (_!P_ (mapOverIdfun (toRepTermF X) (arity o) args)))
        ‚â°‚ü® cong (mapOverIdfun _ _) (tabulateOverLookup-lookupP (mapOverIdfun (toRepTermF X) (arity o) args)) ‚ü©
      mapOverIdfun (fromRepTermF X) (arity o) (mapOverIdfun (toRepTermF X) (arity o) args)
        ‚â°‚ü® sym (mapOverIdfun-‚àò (fromRepTermF X) (toRepTermF X) (arity o)) ‚â°$ args ‚ü©
      mapOverIdfun (Œª a ‚Üí fromRepTermF X a ‚àò toRepTermF X a) (arity o) args
        ‚â°‚ü® (cong mapOverIdfun (funExt Œª sort ‚Üí funExt Œª t ‚Üí fromToRepTermF X sort t) ‚â°$ arity o) ‚â°$ args ‚ü©
      mapOverIdfun (Œª x x‚ÇÅ ‚Üí x‚ÇÅ) (arity o) args
        ‚â°‚ü® mapOverIdfun-idfun (arity o) ‚â°$ args ‚ü©
      args ‚àé
    ))

{-# TERMINATING #-} -- this pragma is ignored if I put this definition also in the module :-O
toFromRepTermF : (X : MType) (sortOut : Sort) (rt : RepTermF X sortOut)
    ‚Üí toRepTermF X sortOut (fromRepTermF X sortOut rt) ‚â° rt
toFromRepTermF X sortOut (node (inl v) u) = cong (node (inl v)) (funExt (Œª ()))
toFromRepTermF X sortOut (node (inr o) args) = cong {B = Œª _ ‚Üí RepTermF X sortOut} (node (inr o)) (
      _!P_ (mapOverIdfun (toRepTermF X) (arity o) (mapOverIdfun (fromRepTermF X) (arity o) (tabulateOverLookup (arity o) args)))
        ‚â°‚ü® cong _!P_ (sym (mapOverIdfun-‚àò
             (toRepTermF X)
             (fromRepTermF X)
             (arity o)
             ‚â°$ (tabulateOverLookup (arity o) args)
           )) ‚ü©
      _!P_ (mapOverIdfun (Œª sort ‚Üí toRepTermF X sort ‚àò fromRepTermF X sort) (arity o) (tabulateOverLookup (arity o) args))
        ‚â°‚ü® cong _!P_
             ((cong mapOverIdfun (funExt Œª sort ‚Üí funExt Œª t ‚Üí toFromRepTermF X sort t)
               ‚â°$ arity o)
               ‚â°$ tabulateOverLookup (arity o) args) ‚ü©
      _!P_ (mapOverIdfun (Œª x x‚ÇÅ ‚Üí x‚ÇÅ) (arity o) (tabulateOverLookup (arity o) args))
        ‚â°‚ü® cong (_!P_ {B = RepTermF X}) (mapOverIdfun-idfun (arity o) ‚â°$ tabulateOverLookup (arity o) args) ‚ü©
      _!P_ (tabulateOverLookup (arity o) args)
        ‚â°‚ü® lookupP-tabulateOverLookup (RepTermF X) (arity o) args ‚ü©
      args ‚àé
    )

module _ where
  isoRepTermF : (X : MType) (sortOut : Sort) ‚Üí TermF X sortOut ‚âÖ RepTermF X sortOut
  fun (isoRepTermF X sortOut) = toRepTermF X sortOut
  inv (isoRepTermF X sortOut) = fromRepTermF X sortOut
  rightInv (isoRepTermF X sortOut) = toFromRepTermF X sortOut
  leftInv (isoRepTermF X sortOut) = fromToRepTermF X sortOut

  pathRepTermF : (X : MType) (sortOut : Sort) ‚Üí TermF X sortOut ‚â° RepTermF X sortOut
  pathRepTermF X sortOut = ua (isoToEquiv (isoRepTermF X sortOut))

  isSetRepTermF : (msetX : MSet) (sortOut : Sort) ‚Üí isSet (RepTermF (mtyp msetX) sortOut)
  isSetRepTermF msetX sortOut = isOfHLevelSuc-IW 1 (Œª sort ‚Üí isSet‚äé (str (msetX sort)) isSetOperation) sortOut

isSetTermF msetX sortOut = subst‚Åª isSet (pathRepTermF (mtyp msetX) sortOut) (isSetRepTermF msetX sortOut)

-- components of TermF as a functor
{-# TERMINATING #-}
mapTermF : ‚àÄ {X Y} ‚Üí (‚àÄ sort ‚Üí X sort ‚Üí Y sort) ‚Üí ‚àÄ sort ‚Üí TermF X sort ‚Üí TermF Y sort
mapTermF f sort (varF x) = varF (f sort x)
mapTermF f sort (astF t) = astF (mapTerm1 (mapTermF f) sort t)

{-# TERMINATING #-}
mapTermF-id : ‚àÄ {X} ‚Üí mapTermF (Œª sort ‚Üí idfun (X sort)) ‚â° (Œª sort ‚Üí idfun (TermF X sort))
mapTermF-id {X} i sort (varF x) = varF x
mapTermF-id {X} i sort (astF t) = (
    astF (mapTerm1 (mapTermF (Œª sort‚ÇÅ ‚Üí idfun (X sort‚ÇÅ))) sort t)
      ‚â°‚ü® cong astF ((cong mapTerm1 mapTermF-id ‚â°$ sort) ‚â°$ t) ‚ü©
    astF (mapTerm1 (Œª sort‚ÇÅ ‚Üí idfun (TermF X sort‚ÇÅ)) sort t)
      ‚â°‚ü® cong astF ((mapTerm1-id ‚â°$ sort) ‚â°$ t) ‚ü©
    astF t ‚àé
  ) i

{-# TERMINATING #-}
mapTermF-‚àò : ‚àÄ {X Y Z : MType} ‚Üí (g : ‚àÄ sort ‚Üí Y sort ‚Üí Z sort) ‚Üí (f : ‚àÄ sort ‚Üí X sort ‚Üí Y sort) ‚Üí
  mapTermF (Œª sort ‚Üí g sort ‚àò f sort) ‚â° (Œª sort ‚Üí mapTermF g sort ‚àò mapTermF f sort)
mapTermF-‚àò g f i sort (varF x) = varF (g sort (f sort x))
mapTermF-‚àò g f i sort (astF t) = (
    astF (mapTerm1 (mapTermF (Œª sort' ‚Üí g sort' ‚àò f sort')) sort t)
      ‚â°‚ü® cong astF ((cong mapTerm1 (mapTermF-‚àò g f) ‚â°$ sort) ‚â°$ t) ‚ü©
    astF (mapTerm1 (Œª sort‚ÇÅ ‚Üí mapTermF g sort‚ÇÅ ‚àò mapTermF f sort‚ÇÅ) sort t)
      ‚â°‚ü® cong astF ((mapTerm1-‚àò (mapTermF g) (mapTermF f) ‚â°$ sort) ‚â°$ t) ‚ü©
    astF (mapTerm1 (mapTermF g) sort (mapTerm1 (mapTermF f) sort t)) ‚àé
  ) i

-- TermF as a functor on catMSet
ftrTermF : Functor catMSet catMSet
F-ob ftrTermF = msetTermF
F-hom ftrTermF = mapTermF
F-id ftrTermF = mapTermF-id
F-seq ftrTermF f g = mapTermF-‚àò g f

-- components of TermF as a monad

pureTermF : ‚àÄ {X} sort ‚Üí X sort ‚Üí TermF X sort
pureTermF sort = varF

Œ∑TermF : NatTrans (ftrId catMSet) ftrTermF
N-ob Œ∑TermF msetX sortOut = varF
N-hom Œ∑TermF {msetX} {msetY} f = refl

{-# TERMINATING #-}
joinTermF : ‚àÄ {X} sort ‚Üí TermF (TermF X) sort ‚Üí TermF X sort
joinTermF sort (varF t) = t
joinTermF sort (astF t) = astF (mapTerm1 joinTermF sort t)

{-# TERMINATING #-}
joinTermF-nat : ‚àÄ {X Y : MType} f sort ‚Üí (t : TermF (TermF X) sort)
  ‚Üí joinTermF {X = Y} sort (mapTermF (mapTermF f) sort t) ‚â° mapTermF f sort (joinTermF sort t)
joinTermF-nat f sort (varF t) = refl
joinTermF-nat f sort (astF t) = cong astF (((
    (Œª sort ‚Üí mapTerm1 joinTermF sort ‚àò mapTerm1 (mapTermF (mapTermF f)) sort)
      ‚â°‚ü® sym (mapTerm1-‚àò joinTermF (mapTermF (mapTermF f))) ‚ü©
    mapTerm1 (Œª sort‚ÇÅ ‚Üí joinTermF sort‚ÇÅ ‚àò mapTermF (mapTermF f) sort‚ÇÅ)
      ‚â°‚ü® cong mapTerm1 (funExt Œª sort ‚Üí funExt Œª t ‚Üí joinTermF-nat f sort t) ‚ü©
    mapTerm1 (Œª x x‚ÇÅ ‚Üí mapTermF f x (joinTermF x x‚ÇÅ))
      ‚â°‚ü® mapTerm1-‚àò (mapTermF f) joinTermF ‚ü©
    (Œª sort ‚Üí mapTerm1 (mapTermF f) sort ‚àò mapTerm1 joinTermF sort) ‚àé
  ) ‚â°$ sort) ‚â°$ t)

ŒºTermF : NatTrans (funcComp ftrTermF ftrTermF) ftrTermF
N-ob ŒºTermF msetX = joinTermF
N-hom ŒºTermF {msetX} {msetY} f = funExt Œª sort ‚Üí funExt Œª t ‚Üí joinTermF-nat f sort t

open IsMonad

-- TermF is a monad
{-# TERMINATING #-}
ismonadTermF : IsMonad ftrTermF
Œ∑ ismonadTermF = Œ∑TermF
Œº ismonadTermF = ŒºTermF
idl-Œº ismonadTermF = makeNatTransPathP (Œª i ‚Üí F-rUnit i) (Œª i ‚Üí ftrTermF) refl
idr-Œº ismonadTermF = makeNatTransPathP (Œª i ‚Üí F-lUnit i) (Œª i ‚Üí ftrTermF) lemma
  where lemma : (Œª msetX sort t ‚Üí joinTermF sort (mapTermF (Œª sortOut ‚Üí varF) sort t)) ‚â°
                (Œª msetX sort t ‚Üí t)
        lemma i msetX sort (varF x) = varF x
        lemma i msetX sort (astF t) = cong astF (((
            (Œª sort' ‚Üí mapTerm1 joinTermF sort' ‚àò mapTerm1 (mapTermF pureTermF) sort')
              ‚â°‚ü® sym (mapTerm1-‚àò joinTermF (mapTermF pureTermF)) ‚ü©
            mapTerm1 (Œª sort‚ÇÅ ‚Üí joinTermF sort‚ÇÅ ‚àò mapTermF pureTermF sort‚ÇÅ)
              ‚â°‚ü® cong mapTerm1 (lemma ‚â°$ msetX) ‚ü©
            mapTerm1 (Œª a x ‚Üí x)
              ‚â°‚ü® mapTerm1-id ‚ü©
            (Œª sort' t ‚Üí t) ‚àé
          ) ‚â°$ sort) ‚â°$ t) i
assoc-Œº ismonadTermF = makeNatTransPathP (Œª i ‚Üí F-assoc i) (Œª i ‚Üí ftrTermF) lemma
  where lemma : (Œª msetX sort t ‚Üí joinTermF sort (mapTermF joinTermF sort t)) ‚â°
                (Œª msetX sort t ‚Üí joinTermF sort (joinTermF sort t))
        lemma i msetX sort (varF ttx) = joinTermF sort ttx
        lemma i msetX sort (astF t) = cong astF (((
            (Œª sort' ‚Üí mapTerm1 joinTermF sort' ‚àò mapTerm1 (mapTermF joinTermF) sort')
              ‚â°‚ü® sym (mapTerm1-‚àò joinTermF (mapTermF joinTermF)) ‚ü©
            mapTerm1 (Œª sort‚ÇÅ ‚Üí joinTermF sort‚ÇÅ ‚àò mapTermF joinTermF sort‚ÇÅ)
              ‚â°‚ü® cong mapTerm1 (lemma ‚â°$ msetX) ‚ü©
            mapTerm1 (Œª a x ‚Üí joinTermF a (joinTermF a x))
              ‚â°‚ü® mapTerm1-‚àò joinTermF joinTermF ‚ü©
            (Œª sort' ‚Üí mapTerm1 joinTermF sort' ‚àò mapTerm1 joinTermF sort') ‚àé
          ) ‚â°$ sort) ‚â°$ t) i
        --astF (term1 o Œª p ‚Üí lemma i msetX (arity o ! p) (args p))

monadTermF : Monad catMSet
monadTermF = ftrTermF , ismonadTermF

-- SyntaxQ object

SyntaxF : MType
SyntaxF = TermF (mtyp msetEmpty)

msetSyntaxF : MSet
msetSyntaxF = msetTermF msetEmpty
