{-# OPTIONS --cubical --type-in-type #-}

open import Cubical.Foundations.Everything renaming (Iso to _â‰…_ ; funExtâ» to _â‰¡$_)
open import Cubical.Data.List hiding ([_])
open import Cubical.Data.List.Properties
open import Cubical.Data.List.FinData renaming (lookup to _!_)
open import Cubical.Data.Prod
open import Cubical.Data.W.Indexed
open import Cubical.Data.FinData
open import Cubical.Data.Sum
open import Cubical.Data.Sum as âŠ
open import Cubical.Data.Empty
open import Cubical.Data.Nat
open import Cubical.Data.Sigma.Properties
open import Cubical.Foundations.Structure
open import Cubical.Categories.Category
open import Cubical.Categories.Category.Precategory hiding (_[_,_] ; seq')
open import Cubical.Categories.Functor renaming (ğŸ™âŸ¨_âŸ© to ftrId)
open import Cubical.Categories.Instances.Sets
open import Cubical.Categories.Instances.Categories
open import Cubical.Categories.Constructions.Product
open import Cubical.Categories.Monad.Base
open import Cubical.Categories.NaturalTransformation.Base
open import Cubical.Categories.Instances.FunctorAlgebras
open import Cubical.Categories.Instances.EilenbergMoore
open import Cubical.Categories.Adjoint
open import Cubical.Categories.Limits.Initial

open import Mat.Signature
open import Mat.Free.Presentation

-- Terms of the free MAT generated by a free MAT presentation
module Mat.Free.Term {sign : Signature} (fmat : PresentationF sign) where

open _â‰…_
open Category renaming (_âˆ˜_ to _âŠš_)
open Functor
open Signature sign
open PresentationF fmat
open Algebra renaming (str to algStr)
open AlgebraHom
open IsEMAlgebra
open NaturalBijection
open _âŠ£_

-- Free syntax monad
data TermF (X : MType) : (sortOut : Sort) â†’ Type
isSetTermF : (msetX : MSet) (sortOut : Sort) â†’ isSet (TermF (mtyp msetX) sortOut)

-- TermF acting on MSets
msetTermF : MSet â†’ MSet
fst (msetTermF msetX sortOut) = TermF (mtyp msetX) sortOut
snd (msetTermF msetX sortOut) = isSetTermF msetX sortOut

data TermF X where
  varF : âˆ€ {sortOut} â†’ X sortOut â†’ TermF X sortOut
  astF : âˆ€ {sortOut} â†’ Term1 (TermF X) sortOut â†’ TermF X sortOut

-- TermF is really an IW type
module _ where
  RepTermF : (X : MType) (sortOut : Sort) â†’ Type
  RepTermF X sortOut =
    IW (Î» sort â†’ X sort âŠ Operation sort)
      (Î» sort â†’ âŠ.elim (Î» v â†’ âŠ¥) Î» o â†’ Fin (length (arity o)))
      (Î» sort â†’ âŠ.elim (Î» v ()) (Î» o p â†’ arity o ! p))
      sortOut

  toRepTermF : (X : MType) (sortOut : Sort) â†’ TermF X sortOut â†’ RepTermF X sortOut
  toRepTermF X sortOut (varF v) = node (inl v) (Î» ())
  toRepTermF X sortOut (astF (term1 o args)) =
    node (inr o) Î» p â†’ toRepTermF X (arity o ! p) (args p)

  fromRepTermF : (X : MType) (sortOut : Sort) â†’ RepTermF X sortOut â†’ TermF X sortOut
  fromRepTermF X sortOut (node (inl v) u) = varF v
  fromRepTermF X sortOut (node (inr o) args) = astF (term1 o Î» p â†’ fromRepTermF X (arity o ! p) (args p))

  fromToRepTermF : (X : MType) (sortOut : Sort) (t : TermF X sortOut)
    â†’ fromRepTermF X sortOut (toRepTermF X sortOut t) â‰¡ t
  fromToRepTermF X sortOut (varF v) = refl
  fromToRepTermF X sortOut (astF (term1 o args)) i =
    astF (term1 o Î» p â†’ fromToRepTermF X (arity o ! p) (args p) i)

  toFromRepTermF : (X : MType) (sortOut : Sort) (rt : RepTermF X sortOut)
    â†’ toRepTermF X sortOut (fromRepTermF X sortOut rt) â‰¡ rt
  toFromRepTermF X sortOut (node (inl v) u) = cong (node (inl v)) (funExt (Î» ()))
  toFromRepTermF X sortOut (node (inr o) args) i =
    node (inr o) (Î» p â†’ toFromRepTermF X (arity o ! p) (args p) i)

  isoRepTermF : (X : MType) (sortOut : Sort) â†’ TermF X sortOut â‰… RepTermF X sortOut
  fun (isoRepTermF X sortOut) = toRepTermF X sortOut
  inv (isoRepTermF X sortOut) = fromRepTermF X sortOut
  rightInv (isoRepTermF X sortOut) = toFromRepTermF X sortOut
  leftInv (isoRepTermF X sortOut) = fromToRepTermF X sortOut

  pathRepTermF : (X : MType) (sortOut : Sort) â†’ TermF X sortOut â‰¡ RepTermF X sortOut
  pathRepTermF X sortOut = ua (isoToEquiv (isoRepTermF X sortOut))

  isSetRepTermF : (msetX : MSet) (sortOut : Sort) â†’ isSet (RepTermF (mtyp msetX) sortOut)
  isSetRepTermF msetX sortOut = isOfHLevelSuc-IW 1 (Î» sort â†’ isSetâŠ (str (msetX sort)) isSetOperation) sortOut

isSetTermF msetX sortOut = substâ» isSet (pathRepTermF (mtyp msetX) sortOut) (isSetRepTermF msetX sortOut)

-- components of TermF as a functor
mapTermF : âˆ€ {X Y} â†’ (âˆ€ sort â†’ X sort â†’ Y sort) â†’ âˆ€ sort â†’ TermF X sort â†’ TermF Y sort
mapTermF f sort (varF x) = varF (f sort x)
mapTermF f sort (astF (term1 o args)) = astF (term1 o Î» p â†’ mapTermF f (arity o ! p) (args p))

mapTermF-id : âˆ€ {X} â†’ mapTermF (Î» sort â†’ idfun (X sort)) â‰¡ (Î» sort â†’ idfun (TermF X sort))
mapTermF-id i sort (varF x) = varF x
mapTermF-id i sort (astF (term1 o args)) = astF (term1 o (Î» p â†’ mapTermF-id i (arity o ! p) (args p)))

mapTermF-âˆ˜ : âˆ€ {X Y Z : MType} â†’ (g : âˆ€ sort â†’ Y sort â†’ Z sort) â†’ (f : âˆ€ sort â†’ X sort â†’ Y sort) â†’
  mapTermF (Î» sort â†’ g sort âˆ˜ f sort) â‰¡ (Î» sort â†’ mapTermF g sort âˆ˜ mapTermF f sort)
mapTermF-âˆ˜ g f i sort (varF x) = varF (g sort (f sort x))
mapTermF-âˆ˜ g f i sort (astF (term1 o args)) = astF (term1 o (Î» p â†’ mapTermF-âˆ˜ g f i (arity o ! p) (args p)))

-- TermF as a functor on catMSet
ftrTermF : Functor catMSet catMSet
F-ob ftrTermF = msetTermF
F-hom ftrTermF = mapTermF
F-id ftrTermF = mapTermF-id
F-seq ftrTermF f g = mapTermF-âˆ˜ g f

open NatTrans

-- components of TermF as a monad

pureTermF : âˆ€ {X} sort â†’ X sort â†’ TermF X sort
pureTermF sort = varF

Î·TermF : NatTrans (ftrId catMSet) ftrTermF
N-ob Î·TermF msetX sortOut = varF
N-hom Î·TermF {msetX} {msetY} f = refl

joinTermF : âˆ€ {X} sort â†’ TermF (TermF X) sort â†’ TermF X sort
joinTermF sort (varF t) = t
joinTermF sort (astF (term1 o args)) = astF (term1 o (Î» p â†’ joinTermF (arity o ! p) (args p)))

joinTermF-nat : âˆ€ {X Y : MType} f sort â†’ (t : TermF (TermF X) sort)
  â†’ joinTermF {X = Y} sort (mapTermF (mapTermF f) sort t) â‰¡ mapTermF f sort (joinTermF sort t)
joinTermF-nat f sort (varF t) = refl
joinTermF-nat f sort (astF (term1 o args)) i = astF (term1 o Î» p â†’ joinTermF-nat f (arity o ! p) (args p) i)

Î¼TermF : NatTrans (funcComp ftrTermF ftrTermF) ftrTermF
N-ob Î¼TermF msetX = joinTermF
N-hom Î¼TermF {msetX} {msetY} f = funExt Î» sort â†’ funExt Î» t â†’ joinTermF-nat f sort t

open IsMonad

-- TermF is a monad
ismonadTermF : IsMonad ftrTermF
Î· ismonadTermF = Î·TermF
Î¼ ismonadTermF = Î¼TermF
idl-Î¼ ismonadTermF = makeNatTransPathP (Î» i â†’ F-rUnit i) (Î» i â†’ ftrTermF) refl
idr-Î¼ ismonadTermF = makeNatTransPathP (Î» i â†’ F-lUnit i) (Î» i â†’ ftrTermF) lemma
  where lemma : (Î» msetX sort t â†’ joinTermF sort (mapTermF (Î» sortOut â†’ varF) sort t)) â‰¡
                (Î» msetX sort t â†’ t)
        lemma i msetX sort (varF x) = varF x
        lemma i msetX sort (astF (term1 o args)) = astF (term1 o Î» p â†’ lemma i msetX (arity o ! p) (args p))
assoc-Î¼ ismonadTermF = makeNatTransPathP (Î» i â†’ F-assoc i) (Î» i â†’ ftrTermF) lemma
  where lemma : (Î» msetX sort t â†’ joinTermF sort (mapTermF joinTermF sort t)) â‰¡
                (Î» msetX sort t â†’ joinTermF sort (joinTermF sort t))
        lemma i msetX sort (varF ttx) = joinTermF sort ttx
        lemma i msetX sort (astF (term1 o args)) = astF (term1 o Î» p â†’ lemma i msetX (arity o ! p) (args p))

monadTermF : Monad catMSet
monadTermF = ftrTermF , ismonadTermF

-- Models are Eilenberg-Moore algebras of monadTermF
catModelF : Category â„“-zero â„“-zero
catModelF = EMCategory monadTermF

ModelF : Type â„“-zero
ModelF = ob catModelF

ModelFHom : (mFA mFB : ModelF) â†’ Type â„“-zero
ModelFHom = Hom[_,_] catModelF

-- Forgetful functor sending models to their carrier
ftrForgetModelF : Functor catModelF catMSet
ftrForgetModelF = ForgetEMAlgebra monadTermF

-- Free model functor
ftrFreeModelF : Functor catMSet catModelF
ftrFreeModelF = FreeEMAlgebra monadTermF

adjModelF : ftrFreeModelF âŠ£ ftrForgetModelF
adjModelF = emAdjunction monadTermF

-- Recursion/folding (with metavariables) and properties

mFFoldModelF : (msetX : MSet) â†’ (mFA : ModelF)
  â†’ catMSet [ msetX , F-ob ftrForgetModelF mFA ]
  â†’ catModelF [ F-ob ftrFreeModelF msetX , mFA ]
mFFoldModelF msetX mFA = _â™¯ adjModelF {c = msetX} {d = mFA}

foldModelF : (msetX : MSet) â†’ (mFA : ModelF)
  â†’ catMSet [ msetX , F-ob ftrForgetModelF mFA ]
  â†’ âˆ€ sort â†’ TermF (mtyp msetX) sort â†’ typ (carrier (fst mFA) sort)
foldModelF msetX mFA f = mFFoldModelF msetX mFA f .carrierHom

mFFoldModelF-nat :  (msetX : MSet) â†’ (mFA mFB : ModelF)
  â†’ (mFG : catModelF [ mFA , mFB ])
  â†’ (f : catMSet [ msetX , F-ob ftrForgetModelF mFA ])
  â†’ mFFoldModelF msetX mFB (_â‹†_
      catMSet
      {x = msetX}
      {y = F-ob ftrForgetModelF mFA}
      {z = F-ob ftrForgetModelF mFB}
      f
      (F-hom ftrForgetModelF {x = mFA} {y = mFB} mFG)
    )
  â‰¡ _â‹†_ catModelF {x = F-ob ftrFreeModelF msetX} {mFA} {mFB} (mFFoldModelF msetX mFA f) mFG
mFFoldModelF-nat msetX mFA mFB mFG f =
  sym (adjNatInD' adjModelF {c = msetX} {d = mFA} {d' = mFB} f mFG)

foldModelF-nat : (msetX : MSet) â†’ (mFA mFB : ModelF)
  â†’ (mFG : catModelF [ mFA , mFB ])
  â†’ (f : catMSet [ msetX , F-ob ftrForgetModelF mFA ])
  â†’ foldModelF msetX mFB (Î» sort â†’ F-hom ftrForgetModelF {x = mFA} {y = mFB} mFG sort âˆ˜ f sort)
   â‰¡ (Î» sort â†’ F-hom ftrForgetModelF {x = mFA} {y = mFB} mFG sort âˆ˜ foldModelF msetX mFA f sort)
foldModelF-nat msetX mFA mFB mFG f i = mFFoldModelF-nat msetX mFA mFB mFG f i .carrierHom

mFFoldModelF-uniq : (msetX : MSet) â†’ (mFA : ModelF)
  â†’ (f : catMSet [ msetX , F-ob ftrForgetModelF mFA ])
  â†’ (mFG : catModelF [ F-ob ftrFreeModelF msetX , mFA ])
  â†’ (Î» sort â†’ mFG .carrierHom sort âˆ˜ pureTermF sort) â‰¡ f
  â†’ mFFoldModelF msetX mFA f â‰¡ mFG
mFFoldModelF-uniq msetX mFA f mFG ef =
  mFFoldModelF msetX mFA f
    â‰¡âŸ¨âŸ©
  _â™¯ adjModelF {c = msetX} {d = mFA} f
    â‰¡âŸ¨ cong (_â™¯ adjModelF {c = msetX} {d = mFA}) (sym ef) âŸ©
  _â™¯ adjModelF {c = msetX} {d = mFA} (Î» sort â†’ mFG .carrierHom sort âˆ˜ pureTermF sort)
    â‰¡âŸ¨âŸ©
  _â™¯ adjModelF {c = msetX} {d = mFA} (_â™­ adjModelF {c = msetX} {d = mFA} mFG)
    â‰¡âŸ¨ adjModelF .adjIso {c = msetX} {d = mFA} .leftInv mFG âŸ©
  mFG âˆ

foldModelF-uniq : (msetX : MSet) â†’ (mFA : ModelF)
  â†’ (f : catMSet [ msetX , F-ob ftrForgetModelF mFA ])
  â†’ (mFG : catModelF [ F-ob ftrFreeModelF msetX , mFA ])
  â†’ (Î» sort â†’ mFG .carrierHom sort âˆ˜ pureTermF sort) â‰¡ f
  â†’ foldModelF msetX mFA f â‰¡ mFG .carrierHom
foldModelF-uniq msetX mFA f mFG ef i = mFFoldModelF-uniq msetX mFA f mFG ef i .carrierHom

foldModelF-uniq2 : (msetX : MSet) â†’ (mFA : ModelF)
  â†’ (mFG mFH : catModelF [ F-ob ftrFreeModelF msetX , mFA ])
  â†’ (Î» (sort : Sort) â†’ mFG .carrierHom sort âˆ˜ pureTermF sort)
   â‰¡ (Î» (sort : Sort) â†’ mFH .carrierHom sort âˆ˜ pureTermF sort)
  â†’ mFG .carrierHom â‰¡ mFH .carrierHom
foldModelF-uniq2 msetX mFA mFG mFH e =
  mFG .carrierHom
    â‰¡âŸ¨ sym (foldModelF-uniq msetX mFA (Î» sort â†’ mFG .carrierHom sort âˆ˜ pureTermF sort) mFG refl) âŸ©
  foldModelF msetX mFA (Î» sort â†’ mFG .carrierHom sort âˆ˜ pureTermF sort)
    â‰¡âŸ¨ foldModelF-uniq msetX mFA (Î» sort â†’ mFG .carrierHom sort âˆ˜ pureTermF sort) mFH (sym e) âŸ©
  mFH .carrierHom âˆ

-- Sending models of Term1 to models of TermF
module _ where
  model1â†’F-algStr : ((algebra msetA Î±) : Model1) â†’ IsAlgebra ftrTermF msetA
  model1â†’F-algStr (algebra msetA Î±) sort (varF a) = a
  model1â†’F-algStr (algebra msetA Î±) sort (astF (term1 o args)) =
    Î± sort (term1 o Î» p â†’ model1â†’F-algStr (algebra msetA Î±) (arity o ! p) (args p))

  model1â†’F-algStr-joinTermF :
    ((algebra msetA Î±) : Model1) â†’
    âˆ€ sort â†’
    (tta : TermF (Î» sortâ‚ â†’ TermF (Î» sortâ‚‚ â†’ fst (msetA sortâ‚‚)) sortâ‚) sort) â†’
    model1â†’F-algStr (algebra msetA Î±) sort (joinTermF sort tta) â‰¡
    model1â†’F-algStr (algebra msetA Î±) sort (mapTermF (model1â†’F-algStr (algebra msetA Î±)) sort tta)
  model1â†’F-algStr-joinTermF (algebra msetA Î±) sort (varF ta) = refl
  model1â†’F-algStr-joinTermF (algebra msetA Î±) sort (astF (term1 o args)) =
    cong (Î± sort) (cong (term1 o) (funExt Î» p â†’ model1â†’F-algStr-joinTermF (algebra msetA Î±) (arity o ! p) (args p)))

  model1â†’F : Model1 â†’ ModelF
  carrier (fst (model1â†’F (algebra msetA Î±))) = msetA
  algStr (fst (model1â†’F (algebra msetA Î±))) = model1â†’F-algStr (algebra msetA Î±)
  str-Î· (snd (model1â†’F (algebra msetA Î±))) = refl
  str-Î¼ (snd (model1â†’F (algebra msetA Î±))) = funExt Î» sort â†’ funExt Î» tta â†’ model1â†’F-algStr-joinTermF (algebra msetA Î±) sort tta

  model1â†’F-ishom : âˆ€ {(algebra msetA Î±) (algebra msetB Î²) : Algebra ftrTerm1} â†’ ((algebraHom f isalgF)
    : Model1Hom (algebra msetA Î±) (algebra msetB Î²)) â†’ âˆ€ sort ta
    â†’ f sort (model1â†’F-algStr (algebra msetA Î±) sort ta) â‰¡ model1â†’F-algStr (algebra msetB Î²) sort (mapTermF f sort ta)
  model1â†’F-ishom {algebra msetA Î±} {algebra msetB Î²} (algebraHom f commut) sort (varF a) = refl
  model1â†’F-ishom {algebra msetA Î±} {algebra msetB Î²} (algebraHom f commut) sort (astF (term1 o args)) =
    f sort (Î± sort (term1 o (Î» p â†’ model1â†’F-algStr (algebra msetA Î±) (arity o ! p) (args p))))
      â‰¡âŸ¨ commut' sort (term1 o Î» p â†’ model1â†’F-algStr (algebra msetA Î±) (arity o ! p) (args p)) âŸ©
    Î² sort (term1 o (Î» p â†’ f (arity o ! p) (model1â†’F-algStr (algebra msetA Î±) (arity o ! p) (args p))))
      â‰¡âŸ¨ cong (Î² sort) (cong (term1 o) (funExt Î» p â†’ model1â†’F-ishom (algebraHom f commut) (arity o ! p) (args p))) âŸ©
    Î² sort (term1 o (Î» p â†’ model1â†’F-algStr (algebra msetB Î²) (arity o ! p) (mapTermF f (arity o ! p) (args p)))) âˆ
    where commut' : âˆ€ sort ((term1 o' args') : Term1 (mtyp msetA) sort)
                  â†’ f sort (Î± sort (term1 o' args')) â‰¡ Î² sort (term1 o' Î» p â†’ f (arity o' ! p) (args' p))
          commut' sort ta i = commut i sort ta

  model1â†’F-hom : âˆ€ {m1A m1B} â†’ (m1F : Model1Hom m1A m1B) â†’ ModelFHom (model1â†’F m1A) (model1â†’F m1B)
  carrierHom (model1â†’F-hom {algebra msetA Î±} {algebra msetB Î²} (algebraHom f commut)) = f
  strHom (model1â†’F-hom {algebra msetA Î±} {algebra msetB Î²} (algebraHom f commut)) =
    funExt Î» sort â†’ funExt Î» ta â†’ model1â†’F-ishom (algebraHom f commut) sort ta

  ftrModel1â†’F : Functor catModel1 catModelF
  F-ob ftrModel1â†’F = model1â†’F
  F-hom ftrModel1â†’F = model1â†’F-hom
  F-id ftrModel1â†’F = AlgebraHomâ‰¡ ftrTermF refl
  F-seq ftrModel1â†’F algF algG = AlgebraHomâ‰¡ ftrTermF refl

-- sending models of TermF to models of Term1
module _ where
  nt1â†’F : NatTrans ftrTerm1 ftrTermF
  N-ob nt1â†’F msetA sort (term1 o args) = astF (term1 o Î» p â†’ varF (args p))
  N-hom nt1â†’F f = refl

  ftrModelFâ†’1 : Functor catModelF catModel1
  ftrModelFâ†’1 = funcComp {-{D = AlgebrasCategory ftrTermF}{E = catModel1}{C = catModelF}-}
    (AlgebrasFunctor {F = ftrTerm1} {G = ftrTermF} nt1â†’F)
    (ForgetEM monadTermF)

  modelFâ†’1 : ModelF â†’ Model1
  modelFâ†’1 = F-ob ftrModelFâ†’1

-- Isomorphism components of Model1 â†” ModelF
module _ where
  ftrModel1â†’Fâ†’1 : funcComp ftrModelFâ†’1 ftrModel1â†’F â‰¡ ftrId catModel1
  ftrModel1â†’Fâ†’1 = Functorâ‰¡
    (Î» (algebra msetA Î±) â†’ refl)
    (Î» where
      {algebra msetA Î±} {algebra msetB Î²} (algebraHom f isalgF) â†’ AlgebraHomâ‰¡ ftrTerm1 refl
    )

  ftrModelFâ†’1â†’F : funcComp ftrModel1â†’F ftrModelFâ†’1 â‰¡ ftrId catModelF
  ftrModelFâ†’1â†’F = Functorâ‰¡
    (Î» where
      (algebra msetA Î± , isEMA) â†’ Î£â‰¡Prop
        (Î» algA â†’ isPropIsEMAlgebra monadTermF)
        (cong (algebra msetA) (funExt Î» sort â†’ funExt Î» ta â†’ lemma (algebra msetA Î±) isEMA sort ta))
    )
    (Î» where
      {algebra msetA Î± , isEMA} {algebra msetB Î² , isEMB} (algebraHom f isalgF) â†’
        AlgebraHomPathP ftrTermF refl
    )
    where
      open IsEMAlgebra
      lemma : âˆ€ ((algebra msetA Î±) : Algebra ftrTermF) (isEMA : IsEMAlgebra monadTermF (algebra msetA Î±))
        (sort : Sort) (ta : TermF (Î» sortâ‚ â†’ fst (msetA sortâ‚)) sort) â†’
        model1â†’F-algStr (algebra msetA (Î» sort' (term1 o args) â†’ Î± sort' (astF (term1 o Î» p â†’ varF (args p))))) sort ta
        â‰¡ Î± sort ta
      lemma (algebra msetA Î±) isEMA sort (varF a) = sym ((str-Î· isEMA â‰¡$ sort) â‰¡$ a)
      lemma (algebra msetA Î±) isEMA sort (astF (term1 o args)) =
        Î± sort (astF (term1 o Î» p â†’ varF (model1â†’F-algStr (algebra msetA (Î» sort' (term1 o' args') â†’
                    Î± sort' (astF (term1 o' Î» pâ‚ â†’ varF (args' pâ‚))))) (arity o ! p) (args p))))
          â‰¡âŸ¨ cong (Î± sort) (cong astF (cong (term1 o) (funExt Î» p
              â†’ cong varF (lemma (algebra msetA Î±) isEMA (arity o ! p) (args p))))) âŸ©
        -- (Î± âˆ˜ Î£ var âˆ˜ Î£ Î±) (astF (term1 o args))
        Î± sort (astF (term1 o Î» p â†’ varF (Î± (arity o ! p) (args p))))
          â‰¡âŸ¨âŸ©
        -- (Î± âˆ˜ Î£ Î£* Î± âˆ˜ Î£ var) (astF (term1 o args))
        Î± sort (astF (term1 o Î» p â†’ mapTermF Î± (arity o ! p) (varF (args p))))
          â‰¡âŸ¨ sym ((str-Î¼ isEMA â‰¡$ sort) â‰¡$ astF (term1 o Î» p â†’ varF (args p))) âŸ©
        -- (Î± âˆ˜ Î£ Âµ âˆ˜ Î£ var) (astF (term1 o args))
        Î± sort (joinTermF sort (astF (term1 o Î» p â†’ varF (args p))))
          â‰¡âŸ¨âŸ©
        Î± sort (astF (term1 o args)) âˆ

-- Model1 â‰… ModelF
open PrecatIso
isoftrModel1â‰…F : PrecatIso (CatPrecategory â„“-zero â„“-zero) catModel1 catModelF
mor isoftrModel1â‰…F = ftrModel1â†’F
inv isoftrModel1â‰…F = ftrModelFâ†’1
sec isoftrModel1â‰…F = ftrModelFâ†’1â†’F
ret isoftrModel1â‰…F = ftrModel1â†’Fâ†’1

-- Syntax object
module _ where

  SyntaxF : MType
  SyntaxF = TermF (mtyp msetEmpty)

  msetSyntaxF : MSet
  msetSyntaxF = msetTermF msetEmpty

  mFSyntaxF : ModelF
  mFSyntaxF = F-ob ftrFreeModelF msetEmpty

  open NaturalBijection

  isInitial-mFSyntaxF : isInitial catModelF mFSyntaxF
  isInitial-mFSyntaxF = isLeftAdjointâ†’preservesInitial
    {C = catMSet}
    {D = catModelF}
    ftrFreeModelF
    (ftrForgetModelF , emAdjunction monadTermF)
    msetEmpty
    isInitial-msetEmpty

  m1SyntaxF : Model1
  m1SyntaxF = F-ob ftrModelFâ†’1 mFSyntaxF

  {- Ways to prove initiality of m1SyntaxF:
     - directly (seems stupid)
     - prove that isomorphic precategories are equal
     - prove that mutually inverse functors are adjoint
  -}
