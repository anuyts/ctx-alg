{-# OPTIONS --cubical --type-in-type #-}

open import Cubical.Foundations.Prelude
open import Cubical.Foundations.Function
open import Cubical.Foundations.Univalence
open import Cubical.Foundations.Transport
open import Cubical.Foundations.Isomorphism renaming (Iso to _≅_)
open import Cubical.Data.List hiding ([_])
open import Cubical.Data.List.Properties
open import Cubical.Data.List.FinData renaming (lookup to _!_)
open import Cubical.Data.Prod
open import Cubical.Data.W.Indexed
open import Cubical.Data.FinData
open import Cubical.Data.Sum
open import Cubical.Data.Sum as ⊎
open import Cubical.Data.Empty
open import Cubical.Data.Nat
open import Cubical.Data.Sigma.Properties
open import Cubical.Foundations.Structure
open import Cubical.Categories.Category
open import Cubical.Categories.Category.Precategory hiding (_[_,_] ; seq')
open import Cubical.Categories.Functor renaming (𝟙⟨_⟩ to ftrId)
open import Cubical.Categories.Instances.Sets
open import Cubical.Categories.Instances.Categories
open import Cubical.Categories.Constructions.Product
open import Cubical.Categories.Monad.Base
open import Cubical.Categories.NaturalTransformation.Base
open import Cubical.Categories.Instances.FunctorAlgebras
open import Cubical.Categories.Instances.EilenbergMoore
open import Cubical.Categories.Adjoint
open import Cubical.Categories.Limits.Initial

open import Mat.Signature
open import Mat.Free.Presentation
open import Mat.Free.Term

-- TermQs of the free MAT generated by a free MAT presentation
module Mat.Free.Model {matsig : MatSignature} (fmat : FreeMat matsig) where

open TermF fmat

open _≅_
open Category renaming (_∘_ to _⊚_)
open Functor
open NatTrans
open MatSignature matsig
open FreeMat fmat
open Algebra renaming (str to algStr)
open AlgebraHom
open IsEMAlgebra
open NaturalBijection
open _⊣_

-- ModelQs are Eilenberg-Moore algebras of monadTermF
catModelF : Category ℓ-zero ℓ-zero
catModelF = EMCategory monadTermF

ModelF : Type ℓ-zero
ModelF = ob catModelF

ModelFHom : (mFA mFB : ModelF) → Type ℓ-zero
ModelFHom = Hom[_,_] catModelF

-- Forgetful functor sending models to their carrier
ftrForgetModelF : Functor catModelF catMSet
ftrForgetModelF = ForgetEMAlgebra monadTermF

-- Free model functor
ftrFreeModelF : Functor catMSet catModelF
ftrFreeModelF = FreeEMAlgebra monadTermF

adjModelF : ftrFreeModelF ⊣ ftrForgetModelF
adjModelF = emAdjunction monadTermF

-- Recursion/folding (with metavariables) and properties

mFFoldModelF : (msetX : MSet) → (mFA : ModelF)
  → catMSet [ msetX , F-ob ftrForgetModelF mFA ]
  → catModelF [ F-ob ftrFreeModelF msetX , mFA ]
mFFoldModelF msetX mFA = _♯ adjModelF {c = msetX} {d = mFA}

foldModelF : (msetX : MSet) → (mFA : ModelF)
  → catMSet [ msetX , F-ob ftrForgetModelF mFA ]
  → ∀ sort → TermF (mtyp msetX) sort → typ (carrier (fst mFA) sort)
foldModelF msetX mFA f = mFFoldModelF msetX mFA f .carrierHom

mFFoldModelF-nat :  (msetX : MSet) → (mFA mFB : ModelF)
  → (mFG : catModelF [ mFA , mFB ])
  → (f : catMSet [ msetX , F-ob ftrForgetModelF mFA ])
  → mFFoldModelF msetX mFB (_⋆_
      catMSet
      {x = msetX}
      {y = F-ob ftrForgetModelF mFA}
      {z = F-ob ftrForgetModelF mFB}
      f
      (F-hom ftrForgetModelF {x = mFA} {y = mFB} mFG)
    )
  ≡ _⋆_ catModelF {x = F-ob ftrFreeModelF msetX} {mFA} {mFB} (mFFoldModelF msetX mFA f) mFG
mFFoldModelF-nat msetX mFA mFB mFG f =
  sym (adjNatInD' adjModelF {c = msetX} {d = mFA} {d' = mFB} f mFG)

foldModelF-nat : (msetX : MSet) → (mFA mFB : ModelF)
  → (mFG : catModelF [ mFA , mFB ])
  → (f : catMSet [ msetX , F-ob ftrForgetModelF mFA ])
  → foldModelF msetX mFB (F-hom ftrForgetModelF {x = mFA} {y = mFB} mFG ∘M f)
   ≡ (F-hom ftrForgetModelF {x = mFA} {y = mFB} mFG ∘M foldModelF msetX mFA f)
foldModelF-nat msetX mFA mFB mFG f i = mFFoldModelF-nat msetX mFA mFB mFG f i .carrierHom

mFFoldModelF-uniq : (msetX : MSet) → (mFA : ModelF)
  → (f : catMSet [ msetX , F-ob ftrForgetModelF mFA ])
  → (mFG : catModelF [ F-ob ftrFreeModelF msetX , mFA ])
  → (λ sort → mFG .carrierHom sort ∘ pureTermF sort) ≡ f
  → mFFoldModelF msetX mFA f ≡ mFG
mFFoldModelF-uniq msetX mFA f mFG ef =
  mFFoldModelF msetX mFA f
    ≡⟨⟩
  _♯ adjModelF {c = msetX} {d = mFA} f
    ≡⟨ cong (_♯ adjModelF {c = msetX} {d = mFA}) (sym ef) ⟩
  _♯ adjModelF {c = msetX} {d = mFA} (λ sort → mFG .carrierHom sort ∘ pureTermF sort)
    ≡⟨⟩
  _♯ adjModelF {c = msetX} {d = mFA} (_♭ adjModelF {c = msetX} {d = mFA} mFG)
    ≡⟨ adjModelF .adjIso {c = msetX} {d = mFA} .leftInv mFG ⟩
  mFG ∎

foldModelF-uniq : (msetX : MSet) → (mFA : ModelF)
  → (f : catMSet [ msetX , F-ob ftrForgetModelF mFA ])
  → (mFG : catModelF [ F-ob ftrFreeModelF msetX , mFA ])
  → (λ sort → mFG .carrierHom sort ∘ pureTermF sort) ≡ f
  → foldModelF msetX mFA f ≡ mFG .carrierHom
foldModelF-uniq msetX mFA f mFG ef i = mFFoldModelF-uniq msetX mFA f mFG ef i .carrierHom

foldModelF-uniq2 : (msetX : MSet) → (mFA : ModelF)
  → (mFG mFH : catModelF [ F-ob ftrFreeModelF msetX , mFA ])
  → (λ (sort : Sort) → mFG .carrierHom sort ∘ pureTermF sort)
   ≡ (λ (sort : Sort) → mFH .carrierHom sort ∘ pureTermF sort)
  → mFG .carrierHom ≡ mFH .carrierHom
foldModelF-uniq2 msetX mFA mFG mFH e =
  mFG .carrierHom
    ≡⟨ sym (foldModelF-uniq msetX mFA (λ sort → mFG .carrierHom sort ∘ pureTermF sort) mFG refl) ⟩
  foldModelF msetX mFA (λ sort → mFG .carrierHom sort ∘ pureTermF sort)
    ≡⟨ foldModelF-uniq msetX mFA (λ sort → mFG .carrierHom sort ∘ pureTermF sort) mFH (sym e) ⟩
  mFH .carrierHom ∎

-- Sending models of Term1 to models of TermF
module _ where
  {-# TERMINATING #-}
  model1→F-algStr : ((algebra msetA α) : Model1) → IsAlgebra ftrTermF msetA
  model1→F-algStr (algebra msetA α) sort (varF a) = a
  model1→F-algStr (algebra msetA α) sort (join1F t) =
    α sort (mapTerm1 (model1→F-algStr (algebra msetA α)) sort t)
    --α sort (term1 o λ p → model1→F-algStr (algebra msetA α) (arity o ! p) (args p))

  {-# TERMINATING #-}
  model1→F-str-μ :  (m1a : Model1)
    → model1→F-algStr m1a ∘M joinTermF
     ≡ model1→F-algStr m1a ∘M mapTermF (model1→F-algStr m1a)
  model1→F-str-μ m1a = {!!}

  {-# TERMINATING #-}
  model1→F-algStr-joinTermF :
    ((algebra msetA α) : Model1) →
    ∀ sort →
    (tta : TermF (TermF (mtyp msetA)) sort) →
    model1→F-algStr (algebra msetA α) sort (joinTermF sort tta) ≡
    model1→F-algStr (algebra msetA α) sort (mapTermF (model1→F-algStr (algebra msetA α)) sort tta)
  model1→F-algStr-joinTermF algA@(algebra msetA α) sort (varF ta) = refl
  model1→F-algStr-joinTermF algA@(algebra msetA α) sort (join1F t) =
    congS (α sort) (((
      (λ sort' → mapTerm1 (model1→F-algStr algA) sort' ∘ mapTerm1 joinTermF sort')
        ≡⟨ sym (mapTerm1-∘ (model1→F-algStr algA) joinTermF) ⟩
      mapTerm1 (λ sort₁ → model1→F-algStr algA sort₁ ∘ joinTermF sort₁)
        ≡⟨ cong mapTerm1 (funExt λ sort' → funExt λ tta → model1→F-algStr-joinTermF algA sort' tta) ⟩
      mapTerm1 (λ sort' → model1→F-algStr algA sort' ∘ mapTermF (model1→F-algStr algA) sort')
        ≡⟨ mapTerm1-∘ (model1→F-algStr algA) (mapTermF (model1→F-algStr algA)) ⟩
      (λ sort₁ → mapTerm1 (model1→F-algStr algA) sort₁ ∘ mapTerm1 (mapTermF (model1→F-algStr algA)) sort₁) ∎
    ) ≡$ sort) ≡$S t)

  model1→F : Model1 → ModelF
  carrier (fst (model1→F (algebra msetA α))) = msetA
  algStr (fst (model1→F (algebra msetA α))) = model1→F-algStr (algebra msetA α)
  str-η (snd (model1→F (algebra msetA α))) = refl
  str-μ (snd (model1→F (algebra msetA α))) =
    funExt λ sort → funExt λ tta → model1→F-algStr-joinTermF (algebra msetA α) sort tta

  {-# TERMINATING #-}
  model1→F-ishom : ∀ {(algebra msetA α) (algebra msetB β) : Algebra ftrTerm1} → ((algebraHom f isalgF)
    : Model1Hom (algebra msetA α) (algebra msetB β)) → ∀ sort ta
    → f sort (model1→F-algStr (algebra msetA α) sort ta) ≡ model1→F-algStr (algebra msetB β) sort (mapTermF f sort ta)
  model1→F-ishom {algebra msetA α} {algebra msetB β} (algebraHom f commut) sort (varF a) = refl
  model1→F-ishom {algebra msetA α} {algebra msetB β} (algebraHom f commut) sort (join1F t) = ((
      (λ sort' → f sort' ∘ α sort' ∘ mapTerm1 (model1→F-algStr (algebra msetA α)) sort')
        ≡⟨ cong (λ h sort' → h sort' ∘ mapTerm1 (model1→F-algStr (algebra msetA α)) sort') commut ⟩
      (λ sort' → β sort' ∘ mapTerm1 f sort' ∘ mapTerm1 (model1→F-algStr (algebra msetA α)) sort')
        ≡⟨ congS (λ h sort' → β sort' ∘ h sort') (sym (mapTerm1-∘ f (model1→F-algStr (algebra msetA α)))) ⟩
      (λ sort' → β sort' ∘ mapTerm1 (λ sort₁ → f sort₁ ∘ model1→F-algStr (algebra msetA α) sort₁) sort' )
        ≡⟨ congS (λ h sort' → β sort' ∘ h sort')
            (congS mapTerm1 (funExt λ sort'' → funExt λ ta →
              model1→F-ishom {algebra msetA α} {algebra msetB β} (algebraHom f commut) sort'' ta)) ⟩
      (λ sort' → β sort' ∘ mapTerm1 (λ sort'' → model1→F-algStr (algebra msetB β) sort'' ∘ mapTermF f sort'') sort')
        ≡⟨ congS (λ h sort' → β sort' ∘ h sort') (mapTerm1-∘ (model1→F-algStr (algebra msetB β)) (mapTermF f)) ⟩
      (λ sort' → β sort' ∘ mapTerm1 (model1→F-algStr (algebra msetB β)) sort' ∘ mapTerm1 (mapTermF f) sort') ∎
    ) ≡$ sort) ≡$S t

  model1→F-hom : ∀ {m1A m1B} → (m1F : Model1Hom m1A m1B) → ModelFHom (model1→F m1A) (model1→F m1B)
  carrierHom (model1→F-hom {algebra msetA α} {algebra msetB β} (algebraHom f commut)) = f
  strHom (model1→F-hom {algebra msetA α} {algebra msetB β} (algebraHom f commut)) =
    funExt λ sort → funExt λ ta → model1→F-ishom (algebraHom f commut) sort ta

  ftrModel1→F : Functor catModel1 catModelF
  F-ob ftrModel1→F = model1→F
  F-hom ftrModel1→F = model1→F-hom
  F-id ftrModel1→F = AlgebraHom≡ ftrTermF refl
  F-seq ftrModel1→F algF algG = AlgebraHom≡ ftrTermF refl

-- sending models of TermF to models of Term1
module _ where
  nt1→F : NatTrans ftrTerm1 ftrTermF
  N-ob nt1→F msetA sort t = join1F (mapTerm1 pureTermF sort t)
  N-hom nt1→F f =
    (λ sort' → join1F ∘ mapTerm1 pureTermF sort' ∘ mapTerm1 f sort')
      ≡⟨ congS (λ h sort' → join1F ∘ h sort') (
        (λ sort' → mapTerm1 pureTermF sort' ∘ mapTerm1 f sort')
          ≡⟨ sym (mapTerm1-∘ pureTermF f) ⟩
        mapTerm1 (λ sort' → pureTermF sort' ∘ f sort')
          ≡⟨⟩
        mapTerm1 (λ sort → mapTermF f sort ∘ pureTermF sort)
          ≡⟨ mapTerm1-∘ (mapTermF f) pureTermF ⟩
        (λ sort' → mapTerm1 (mapTermF f) sort' ∘ mapTerm1 pureTermF sort') ∎
      ) ⟩
    (λ sort' → join1F ∘ mapTerm1 (mapTermF f) sort' ∘ mapTerm1 pureTermF sort')
      ≡⟨⟩
    (λ sort' → mapTermF f sort' ∘ join1F ∘ mapTerm1 pureTermF sort') ∎

  ftrModelF→1 : Functor catModelF catModel1
  ftrModelF→1 = funcComp {-{D = AlgebrasCategory ftrTermF}{E = catModel1}{C = catModelF}-}
    (AlgebrasFunctor {F = ftrTerm1} {G = ftrTermF} nt1→F)
    (ForgetEM monadTermF)

  modelF→1 : ModelF → Model1
  modelF→1 = F-ob ftrModelF→1

-- Isomorphism components of Model1 ↔ ModelF
module _ where
  ftrModel1→F→1 : funcComp ftrModelF→1 ftrModel1→F ≡ ftrId catModel1
  ftrModel1→F→1 = Functor≡
    (λ where
      (algebra msetA α) → cong₂ algebra refl (
          (λ sort' → model1→F-algStr (algebra msetA α) sort' ∘ join1F ∘ mapTerm1 pureTermF sort')
            ≡⟨⟩
          (λ sort' → α sort' ∘ mapTerm1 (model1→F-algStr (algebra msetA α)) sort' ∘ mapTerm1 pureTermF sort')
            ≡⟨ congS (λ h sort' → α sort' ∘ h sort') (
              (λ sort' → mapTerm1 (model1→F-algStr (algebra msetA α)) sort' ∘ mapTerm1 pureTermF sort')
                ≡⟨ sym (mapTerm1-∘ _ _) ⟩
              mapTerm1 (λ sort → model1→F-algStr (algebra msetA α) sort ∘ pureTermF sort)
                ≡⟨⟩
              mapTerm1 (λ sort → idfun _)
                ≡⟨ mapTerm1-id ⟩
              (λ sort → idfun _) ∎
            ) ⟩
          α ∎
        )
    )
    (λ where
      {algebra msetA α} {algebra msetB β} (algebraHom f isalgF) → AlgebraHomPathP ftrTerm1 refl
    )

  {-# TERMINATING #-}
  ftrModelF→1→F : funcComp ftrModel1→F ftrModelF→1 ≡ ftrId catModelF
  ftrModelF→1→F = Functor≡
    (λ where
      (algebra msetA α , isEMA) → Σ≡Prop
        (λ algA → isPropIsEMAlgebra monadTermF)
        (cong (algebra msetA) (funExt λ sort → funExt λ ta → lemma (algebra msetA α) isEMA sort ta))
    )
    (λ where
      {algebra msetA α , isEMA} {algebra msetB β , isEMB} (algebraHom f isalgF) →
        AlgebraHomPathP ftrTermF refl
    )
    where
      open IsEMAlgebra
      lemma : ∀ ((algebra msetA α) : Algebra ftrTermF) (isEMA : IsEMAlgebra monadTermF (algebra msetA α))
        (sort : Sort) (ta : TermF (λ sort₁ → fst (msetA sort₁)) sort) →
        model1→F-algStr (algebra msetA (λ sort' → α sort' ∘ join1F ∘ mapTerm1 pureTermF sort')) sort ta
        ≡ α sort ta
      lemma (algebra msetA α) isEMA sort (varF a) = sym ((str-η isEMA ≡$ sort) ≡$ a)
      lemma (algebra msetA α) isEMA sort (join1F t) = ((
          (λ sort' → α sort' ∘ join1F ∘ mapTerm1 pureTermF sort' ∘
            mapTerm1 (model1→F-algStr (algebra msetA (λ sort' → α sort' ∘ join1F ∘ mapTerm1 pureTermF sort'))) sort')
            ≡⟨ congS (λ h sort' → α sort' ∘ join1F ∘ mapTerm1 pureTermF sort' ∘ h sort')
                 (cong mapTerm1 (funExt λ sort' → funExt λ ta → lemma (algebra msetA α) isEMA sort' ta)) ⟩
          (λ sort' → α sort' ∘ join1F ∘ mapTerm1 pureTermF sort' ∘ mapTerm1 α sort')
            ≡⟨ congS (λ h sort' → α sort' ∘ join1F ∘ h sort') (sym (mapTerm1-∘ pureTermF α)) ⟩
          (λ sort' → α sort' ∘ join1F ∘ mapTerm1 (λ sort₁ → pureTermF sort₁ ∘ α sort₁) sort')
            ≡⟨⟩
          (λ sort' → α sort' ∘ join1F ∘ mapTerm1 (λ sort₁ → mapTermF α sort₁ ∘ pureTermF sort₁) sort')
            ≡⟨ congS (λ h sort' → α sort' ∘ join1F ∘ h sort') (mapTerm1-∘ (mapTermF α) pureTermF) ⟩
          (λ sort' → α sort' ∘ join1F ∘ mapTerm1 (mapTermF α) sort' ∘ mapTerm1 pureTermF sort')
            ≡⟨⟩
          (λ sort' → α sort' ∘ mapTermF α sort' ∘ join1F ∘ mapTerm1 pureTermF sort')
            ≡⟨ congS (λ h sort' → h sort' ∘ join1F ∘ mapTerm1 pureTermF sort') (sym (str-μ isEMA)) ⟩
          (λ sort' → α sort' ∘ joinTermF sort' ∘ join1F ∘ mapTerm1 pureTermF sort')
            ≡⟨⟩
          (λ sort' → α sort' ∘ join1F ∘ mapTerm1 joinTermF sort' ∘ mapTerm1 pureTermF sort')
            ≡⟨ congS (λ h sort' → α sort' ∘ join1F ∘ h sort') (sym (mapTerm1-∘ joinTermF pureTermF)) ⟩
          (λ sort' → α sort' ∘ join1F ∘ mapTerm1 (λ sort'' → idfun _) sort')
            ≡⟨ congS (λ h sort' → α sort' ∘ join1F ∘ h sort') mapTerm1-id ⟩
          (λ sort' → α sort' ∘ join1F) ∎
        ) ≡$ sort) ≡$S t

-- Model1 ≅ ModelF
open PrecatIso
isoftrModel1≅F : PrecatIso (CatPrecategory ℓ-zero ℓ-zero) catModel1 catModelF
mor isoftrModel1≅F = ftrModel1→F
inv isoftrModel1≅F = ftrModelF→1
sec isoftrModel1≅F = ftrModelF→1→F
ret isoftrModel1≅F = ftrModel1→F→1

-- SyntaxQ object
module _ where

  mFSyntaxF : ModelF
  mFSyntaxF = F-ob ftrFreeModelF msetEmpty

  open NaturalBijection

  isInitial-mFSyntaxF : isInitial catModelF mFSyntaxF
  isInitial-mFSyntaxF = isLeftAdjoint→preservesInitial
    {C = catMSet}
    {D = catModelF}
    ftrFreeModelF
    (ftrForgetModelF , emAdjunction monadTermF)
    msetEmpty
    isInitial-msetEmpty

  m1SyntaxF : Model1
  m1SyntaxF = F-ob ftrModelF→1 mFSyntaxF

  {- Ways to prove initiality of m1SyntaxF:
     - directly (seems stupid)
     - prove that isomorphic precategories are equal
     - prove that mutually inverse functors are adjoint
  -}
