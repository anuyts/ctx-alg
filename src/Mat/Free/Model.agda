{-# OPTIONS --cubical --type-in-type #-}

open import Cubical.Foundations.Everything renaming (Iso to _â‰…_ ; funExtâ» to _â‰¡$_)
open import Cubical.Data.List hiding ([_])
open import Cubical.Data.List.Properties
open import Cubical.Data.List.FinData renaming (lookup to _!_)
open import Cubical.Data.Prod
open import Cubical.Data.W.Indexed
open import Cubical.Data.FinData
open import Cubical.Data.Sum
open import Cubical.Data.Sum as âŠ
open import Cubical.Data.Empty
open import Cubical.Data.Nat
open import Cubical.Data.Sigma.Properties
open import Cubical.Foundations.Structure
open import Cubical.Categories.Category
open import Cubical.Categories.Category.Precategory hiding (_[_,_] ; seq')
open import Cubical.Categories.Functor renaming (ğŸ™âŸ¨_âŸ© to ftrId)
open import Cubical.Categories.Instances.Sets
open import Cubical.Categories.Instances.Categories
open import Cubical.Categories.Constructions.Product
open import Cubical.Categories.Monad.Base
open import Cubical.Categories.NaturalTransformation.Base
open import Cubical.Categories.Instances.FunctorAlgebras
open import Cubical.Categories.Instances.EilenbergMoore
open import Cubical.Categories.Adjoint
open import Cubical.Categories.Limits.Initial

open import Mat.Signature
open import Mat.Free.Presentation
import Mat.Free.Term

-- TermQs of the free MAT generated by a free MAT presentation
module Mat.Free.Model {sign : Signature} (fmat : FreeMat sign) where

open Mat.Free.Term fmat

open _â‰…_
open Category renaming (_âˆ˜_ to _âŠš_)
open Functor
open NatTrans
open Signature sign
open FreeMat fmat
open Algebra renaming (str to algStr)
open AlgebraHom
open IsEMAlgebra
open NaturalBijection
open _âŠ£_

-- ModelQs are Eilenberg-Moore algebras of monadTermF
catModelF : Category â„“-zero â„“-zero
catModelF = EMCategory monadTermF

ModelF : Type â„“-zero
ModelF = ob catModelF

ModelFHom : (mFA mFB : ModelF) â†’ Type â„“-zero
ModelFHom = Hom[_,_] catModelF

-- Forgetful functor sending models to their carrier
ftrForgetModelF : Functor catModelF catMSet
ftrForgetModelF = ForgetEMAlgebra monadTermF

-- Free model functor
ftrFreeModelF : Functor catMSet catModelF
ftrFreeModelF = FreeEMAlgebra monadTermF

adjModelF : ftrFreeModelF âŠ£ ftrForgetModelF
adjModelF = emAdjunction monadTermF

-- Recursion/folding (with metavariables) and properties

mFFoldModelF : (msetX : MSet) â†’ (mFA : ModelF)
  â†’ catMSet [ msetX , F-ob ftrForgetModelF mFA ]
  â†’ catModelF [ F-ob ftrFreeModelF msetX , mFA ]
mFFoldModelF msetX mFA = _â™¯ adjModelF {c = msetX} {d = mFA}

foldModelF : (msetX : MSet) â†’ (mFA : ModelF)
  â†’ catMSet [ msetX , F-ob ftrForgetModelF mFA ]
  â†’ âˆ€ sort â†’ TermF (mtyp msetX) sort â†’ typ (carrier (fst mFA) sort)
foldModelF msetX mFA f = mFFoldModelF msetX mFA f .carrierHom

mFFoldModelF-nat :  (msetX : MSet) â†’ (mFA mFB : ModelF)
  â†’ (mFG : catModelF [ mFA , mFB ])
  â†’ (f : catMSet [ msetX , F-ob ftrForgetModelF mFA ])
  â†’ mFFoldModelF msetX mFB (_â‹†_
      catMSet
      {x = msetX}
      {y = F-ob ftrForgetModelF mFA}
      {z = F-ob ftrForgetModelF mFB}
      f
      (F-hom ftrForgetModelF {x = mFA} {y = mFB} mFG)
    )
  â‰¡ _â‹†_ catModelF {x = F-ob ftrFreeModelF msetX} {mFA} {mFB} (mFFoldModelF msetX mFA f) mFG
mFFoldModelF-nat msetX mFA mFB mFG f =
  sym (adjNatInD' adjModelF {c = msetX} {d = mFA} {d' = mFB} f mFG)

foldModelF-nat : (msetX : MSet) â†’ (mFA mFB : ModelF)
  â†’ (mFG : catModelF [ mFA , mFB ])
  â†’ (f : catMSet [ msetX , F-ob ftrForgetModelF mFA ])
  â†’ foldModelF msetX mFB (Î» sort â†’ F-hom ftrForgetModelF {x = mFA} {y = mFB} mFG sort âˆ˜ f sort)
   â‰¡ (Î» sort â†’ F-hom ftrForgetModelF {x = mFA} {y = mFB} mFG sort âˆ˜ foldModelF msetX mFA f sort)
foldModelF-nat msetX mFA mFB mFG f i = mFFoldModelF-nat msetX mFA mFB mFG f i .carrierHom

mFFoldModelF-uniq : (msetX : MSet) â†’ (mFA : ModelF)
  â†’ (f : catMSet [ msetX , F-ob ftrForgetModelF mFA ])
  â†’ (mFG : catModelF [ F-ob ftrFreeModelF msetX , mFA ])
  â†’ (Î» sort â†’ mFG .carrierHom sort âˆ˜ pureTermF sort) â‰¡ f
  â†’ mFFoldModelF msetX mFA f â‰¡ mFG
mFFoldModelF-uniq msetX mFA f mFG ef =
  mFFoldModelF msetX mFA f
    â‰¡âŸ¨âŸ©
  _â™¯ adjModelF {c = msetX} {d = mFA} f
    â‰¡âŸ¨ cong (_â™¯ adjModelF {c = msetX} {d = mFA}) (sym ef) âŸ©
  _â™¯ adjModelF {c = msetX} {d = mFA} (Î» sort â†’ mFG .carrierHom sort âˆ˜ pureTermF sort)
    â‰¡âŸ¨âŸ©
  _â™¯ adjModelF {c = msetX} {d = mFA} (_â™­ adjModelF {c = msetX} {d = mFA} mFG)
    â‰¡âŸ¨ adjModelF .adjIso {c = msetX} {d = mFA} .leftInv mFG âŸ©
  mFG âˆ

foldModelF-uniq : (msetX : MSet) â†’ (mFA : ModelF)
  â†’ (f : catMSet [ msetX , F-ob ftrForgetModelF mFA ])
  â†’ (mFG : catModelF [ F-ob ftrFreeModelF msetX , mFA ])
  â†’ (Î» sort â†’ mFG .carrierHom sort âˆ˜ pureTermF sort) â‰¡ f
  â†’ foldModelF msetX mFA f â‰¡ mFG .carrierHom
foldModelF-uniq msetX mFA f mFG ef i = mFFoldModelF-uniq msetX mFA f mFG ef i .carrierHom

foldModelF-uniq2 : (msetX : MSet) â†’ (mFA : ModelF)
  â†’ (mFG mFH : catModelF [ F-ob ftrFreeModelF msetX , mFA ])
  â†’ (Î» (sort : Sort) â†’ mFG .carrierHom sort âˆ˜ pureTermF sort)
   â‰¡ (Î» (sort : Sort) â†’ mFH .carrierHom sort âˆ˜ pureTermF sort)
  â†’ mFG .carrierHom â‰¡ mFH .carrierHom
foldModelF-uniq2 msetX mFA mFG mFH e =
  mFG .carrierHom
    â‰¡âŸ¨ sym (foldModelF-uniq msetX mFA (Î» sort â†’ mFG .carrierHom sort âˆ˜ pureTermF sort) mFG refl) âŸ©
  foldModelF msetX mFA (Î» sort â†’ mFG .carrierHom sort âˆ˜ pureTermF sort)
    â‰¡âŸ¨ foldModelF-uniq msetX mFA (Î» sort â†’ mFG .carrierHom sort âˆ˜ pureTermF sort) mFH (sym e) âŸ©
  mFH .carrierHom âˆ

-- Sending models of Term1 to models of TermF
module _ where
  model1â†’F-algStr : ((algebra msetA Î±) : Model1) â†’ IsAlgebra ftrTermF msetA
  model1â†’F-algStr (algebra msetA Î±) sort (varF a) = a
  model1â†’F-algStr (algebra msetA Î±) sort (astF (term1 o args)) =
    Î± sort (term1 o Î» p â†’ model1â†’F-algStr (algebra msetA Î±) (arity o ! p) (args p))

  model1â†’F-algStr-joinTermF :
    ((algebra msetA Î±) : Model1) â†’
    âˆ€ sort â†’
    (tta : TermF (Î» sortâ‚ â†’ TermF (Î» sortâ‚‚ â†’ fst (msetA sortâ‚‚)) sortâ‚) sort) â†’
    model1â†’F-algStr (algebra msetA Î±) sort (joinTermF sort tta) â‰¡
    model1â†’F-algStr (algebra msetA Î±) sort (mapTermF (model1â†’F-algStr (algebra msetA Î±)) sort tta)
  model1â†’F-algStr-joinTermF (algebra msetA Î±) sort (varF ta) = refl
  model1â†’F-algStr-joinTermF (algebra msetA Î±) sort (astF (term1 o args)) =
    cong (Î± sort) (cong (term1 o) (funExt Î» p â†’ model1â†’F-algStr-joinTermF (algebra msetA Î±) (arity o ! p) (args p)))

  model1â†’F : Model1 â†’ ModelF
  carrier (fst (model1â†’F (algebra msetA Î±))) = msetA
  algStr (fst (model1â†’F (algebra msetA Î±))) = model1â†’F-algStr (algebra msetA Î±)
  str-Î· (snd (model1â†’F (algebra msetA Î±))) = refl
  str-Î¼ (snd (model1â†’F (algebra msetA Î±))) = funExt Î» sort â†’ funExt Î» tta â†’ model1â†’F-algStr-joinTermF (algebra msetA Î±) sort tta

  model1â†’F-ishom : âˆ€ {(algebra msetA Î±) (algebra msetB Î²) : Algebra ftrTerm1} â†’ ((algebraHom f isalgF)
    : Model1Hom (algebra msetA Î±) (algebra msetB Î²)) â†’ âˆ€ sort ta
    â†’ f sort (model1â†’F-algStr (algebra msetA Î±) sort ta) â‰¡ model1â†’F-algStr (algebra msetB Î²) sort (mapTermF f sort ta)
  model1â†’F-ishom {algebra msetA Î±} {algebra msetB Î²} (algebraHom f commut) sort (varF a) = refl
  model1â†’F-ishom {algebra msetA Î±} {algebra msetB Î²} (algebraHom f commut) sort (astF (term1 o args)) =
    f sort (Î± sort (term1 o (Î» p â†’ model1â†’F-algStr (algebra msetA Î±) (arity o ! p) (args p))))
      â‰¡âŸ¨ commut' sort (term1 o Î» p â†’ model1â†’F-algStr (algebra msetA Î±) (arity o ! p) (args p)) âŸ©
    Î² sort (term1 o (Î» p â†’ f (arity o ! p) (model1â†’F-algStr (algebra msetA Î±) (arity o ! p) (args p))))
      â‰¡âŸ¨ cong (Î² sort) (cong (term1 o) (funExt Î» p â†’ model1â†’F-ishom (algebraHom f commut) (arity o ! p) (args p))) âŸ©
    Î² sort (term1 o (Î» p â†’ model1â†’F-algStr (algebra msetB Î²) (arity o ! p) (mapTermF f (arity o ! p) (args p)))) âˆ
    where commut' : âˆ€ sort ((term1 o' args') : Term1 (mtyp msetA) sort)
                  â†’ f sort (Î± sort (term1 o' args')) â‰¡ Î² sort (term1 o' Î» p â†’ f (arity o' ! p) (args' p))
          commut' sort ta i = commut i sort ta

  model1â†’F-hom : âˆ€ {m1A m1B} â†’ (m1F : Model1Hom m1A m1B) â†’ ModelFHom (model1â†’F m1A) (model1â†’F m1B)
  carrierHom (model1â†’F-hom {algebra msetA Î±} {algebra msetB Î²} (algebraHom f commut)) = f
  strHom (model1â†’F-hom {algebra msetA Î±} {algebra msetB Î²} (algebraHom f commut)) =
    funExt Î» sort â†’ funExt Î» ta â†’ model1â†’F-ishom (algebraHom f commut) sort ta

  ftrModel1â†’F : Functor catModel1 catModelF
  F-ob ftrModel1â†’F = model1â†’F
  F-hom ftrModel1â†’F = model1â†’F-hom
  F-id ftrModel1â†’F = AlgebraHomâ‰¡ ftrTermF refl
  F-seq ftrModel1â†’F algF algG = AlgebraHomâ‰¡ ftrTermF refl

-- sending models of TermF to models of Term1
module _ where
  nt1â†’F : NatTrans ftrTerm1 ftrTermF
  N-ob nt1â†’F msetA sort (term1 o args) = astF (term1 o Î» p â†’ varF (args p))
  N-hom nt1â†’F f = refl

  ftrModelFâ†’1 : Functor catModelF catModel1
  ftrModelFâ†’1 = funcComp {-{D = AlgebrasCategory ftrTermF}{E = catModel1}{C = catModelF}-}
    (AlgebrasFunctor {F = ftrTerm1} {G = ftrTermF} nt1â†’F)
    (ForgetEM monadTermF)

  modelFâ†’1 : ModelF â†’ Model1
  modelFâ†’1 = F-ob ftrModelFâ†’1

-- Isomorphism components of Model1 â†” ModelF
module _ where
  ftrModel1â†’Fâ†’1 : funcComp ftrModelFâ†’1 ftrModel1â†’F â‰¡ ftrId catModel1
  ftrModel1â†’Fâ†’1 = Functorâ‰¡
    (Î» (algebra msetA Î±) â†’ refl)
    (Î» where
      {algebra msetA Î±} {algebra msetB Î²} (algebraHom f isalgF) â†’ AlgebraHomâ‰¡ ftrTerm1 refl
    )

  ftrModelFâ†’1â†’F : funcComp ftrModel1â†’F ftrModelFâ†’1 â‰¡ ftrId catModelF
  ftrModelFâ†’1â†’F = Functorâ‰¡
    (Î» where
      (algebra msetA Î± , isEMA) â†’ Î£â‰¡Prop
        (Î» algA â†’ isPropIsEMAlgebra monadTermF)
        (cong (algebra msetA) (funExt Î» sort â†’ funExt Î» ta â†’ lemma (algebra msetA Î±) isEMA sort ta))
    )
    (Î» where
      {algebra msetA Î± , isEMA} {algebra msetB Î² , isEMB} (algebraHom f isalgF) â†’
        AlgebraHomPathP ftrTermF refl
    )
    where
      open IsEMAlgebra
      lemma : âˆ€ ((algebra msetA Î±) : Algebra ftrTermF) (isEMA : IsEMAlgebra monadTermF (algebra msetA Î±))
        (sort : Sort) (ta : TermF (Î» sortâ‚ â†’ fst (msetA sortâ‚)) sort) â†’
        model1â†’F-algStr (algebra msetA (Î» sort' (term1 o args) â†’ Î± sort' (astF (term1 o Î» p â†’ varF (args p))))) sort ta
        â‰¡ Î± sort ta
      lemma (algebra msetA Î±) isEMA sort (varF a) = sym ((str-Î· isEMA â‰¡$ sort) â‰¡$ a)
      lemma (algebra msetA Î±) isEMA sort (astF (term1 o args)) =
        Î± sort (astF (term1 o Î» p â†’ varF (model1â†’F-algStr (algebra msetA (Î» sort' (term1 o' args') â†’
                    Î± sort' (astF (term1 o' Î» pâ‚ â†’ varF (args' pâ‚))))) (arity o ! p) (args p))))
          â‰¡âŸ¨ cong (Î± sort) (cong astF (cong (term1 o) (funExt Î» p
              â†’ cong varF (lemma (algebra msetA Î±) isEMA (arity o ! p) (args p))))) âŸ©
        -- (Î± âˆ˜ Î£ var âˆ˜ Î£ Î±) (astF (term1 o args))
        Î± sort (astF (term1 o Î» p â†’ varF (Î± (arity o ! p) (args p))))
          â‰¡âŸ¨âŸ©
        -- (Î± âˆ˜ Î£ Î£* Î± âˆ˜ Î£ var) (astF (term1 o args))
        Î± sort (astF (term1 o Î» p â†’ mapTermF Î± (arity o ! p) (varF (args p))))
          â‰¡âŸ¨ sym ((str-Î¼ isEMA â‰¡$ sort) â‰¡$ astF (term1 o Î» p â†’ varF (args p))) âŸ©
        -- (Î± âˆ˜ Î£ Âµ âˆ˜ Î£ var) (astF (term1 o args))
        Î± sort (joinTermF sort (astF (term1 o Î» p â†’ varF (args p))))
          â‰¡âŸ¨âŸ©
        Î± sort (astF (term1 o args)) âˆ

-- Model1 â‰… ModelF
open PrecatIso
isoftrModel1â‰…F : PrecatIso (CatPrecategory â„“-zero â„“-zero) catModel1 catModelF
mor isoftrModel1â‰…F = ftrModel1â†’F
inv isoftrModel1â‰…F = ftrModelFâ†’1
sec isoftrModel1â‰…F = ftrModelFâ†’1â†’F
ret isoftrModel1â‰…F = ftrModel1â†’Fâ†’1

-- SyntaxQ object
module _ where

  mFSyntaxF : ModelF
  mFSyntaxF = F-ob ftrFreeModelF msetEmpty

  open NaturalBijection

  isInitial-mFSyntaxF : isInitial catModelF mFSyntaxF
  isInitial-mFSyntaxF = isLeftAdjointâ†’preservesInitial
    {C = catMSet}
    {D = catModelF}
    ftrFreeModelF
    (ftrForgetModelF , emAdjunction monadTermF)
    msetEmpty
    isInitial-msetEmpty

  m1SyntaxF : Model1
  m1SyntaxF = F-ob ftrModelFâ†’1 mFSyntaxF

  {- Ways to prove initiality of m1SyntaxF:
     - directly (seems stupid)
     - prove that isomorphic precategories are equal
     - prove that mutually inverse functors are adjoint
  -}

