{-# OPTIONS --cubical --type-in-type #-}

open import Cubical.Foundations.Prelude
open import Cubical.Foundations.Function
open import Cubical.Foundations.Univalence
open import Cubical.Foundations.Transport
open import Cubical.Foundations.Isomorphism renaming (Iso to _â‰…_)
open import Cubical.Data.List hiding ([_])
open import Cubical.Data.List.Properties
open import Cubical.Data.List.FinData renaming (lookup to _!_)
open import Cubical.Data.Prod
open import Cubical.Data.W.Indexed
open import Cubical.Data.FinData
open import Cubical.Data.Sum
open import Cubical.Data.Sum as âŠ
open import Cubical.Data.Empty
open import Cubical.Data.Nat
open import Cubical.Data.Sigma.Properties
open import Cubical.Foundations.Structure
open import Cubical.Categories.Category
open import Cubical.Categories.Category.Precategory hiding (_[_,_] ; seq')
open import Cubical.Categories.Functor renaming (ğŸ™âŸ¨_âŸ© to ftrId)
open import Cubical.Categories.Instances.Sets
open import Cubical.Categories.Instances.Categories
open import Cubical.Categories.Constructions.Product
open import Cubical.Categories.Monad.Base
open import Cubical.Categories.NaturalTransformation.Base
open import Cubical.Categories.Instances.FunctorAlgebras
open import Cubical.Categories.Instances.EilenbergMoore
open import Cubical.Categories.Adjoint
open import Cubical.Categories.Limits.Initial

open import Mat.Signature
open import Mat.Free.Presentation
open import Mat.Free.Term

-- TermQs of the free MAT generated by a free MAT presentation
module Mat.Free.Model {matsig : MatSignature} (fmat : FreeMat matsig) where

open TermF fmat

open _â‰…_
open Category renaming (_âˆ˜_ to _âŠš_)
open Functor
open NatTrans
open MatSignature matsig
open FreeMat fmat
open Algebra renaming (str to algStr)
open AlgebraHom
open IsEMAlgebra
open NaturalBijection
open _âŠ£_

-- ModelQs are Eilenberg-Moore algebras of monadTermF
catModelF : Category â„“-zero â„“-zero
catModelF = EMCategory monadTermF

ModelF : Type â„“-zero
ModelF = ob catModelF

ModelFHom : (mFA mFB : ModelF) â†’ Type â„“-zero
ModelFHom = Hom[_,_] catModelF

-- Forgetful functor sending models to their carrier
ftrForgetModelF : Functor catModelF catMSet
ftrForgetModelF = ForgetEMAlgebra monadTermF

-- Free model functor
ftrFreeModelF : Functor catMSet catModelF
ftrFreeModelF = FreeEMAlgebra monadTermF

adjModelF : ftrFreeModelF âŠ£ ftrForgetModelF
adjModelF = emAdjunction monadTermF

-- Recursion/folding (with metavariables) and properties

mFFoldModelF : (msetX : MSet) â†’ (mFA : ModelF)
  â†’ catMSet [ msetX , F-ob ftrForgetModelF mFA ]
  â†’ catModelF [ F-ob ftrFreeModelF msetX , mFA ]
mFFoldModelF msetX mFA = _â™¯ adjModelF {c = msetX} {d = mFA}

foldModelF : (msetX : MSet) â†’ (mFA : ModelF)
  â†’ catMSet [ msetX , F-ob ftrForgetModelF mFA ]
  â†’ âˆ€ sort â†’ TermF (mtyp msetX) sort â†’ typ (carrier (fst mFA) sort)
foldModelF msetX mFA f = mFFoldModelF msetX mFA f .carrierHom

mFFoldModelF-nat :  (msetX : MSet) â†’ (mFA mFB : ModelF)
  â†’ (mFG : catModelF [ mFA , mFB ])
  â†’ (f : catMSet [ msetX , F-ob ftrForgetModelF mFA ])
  â†’ mFFoldModelF msetX mFB (_â‹†_
      catMSet
      {x = msetX}
      {y = F-ob ftrForgetModelF mFA}
      {z = F-ob ftrForgetModelF mFB}
      f
      (F-hom ftrForgetModelF {x = mFA} {y = mFB} mFG)
    )
  â‰¡ _â‹†_ catModelF {x = F-ob ftrFreeModelF msetX} {mFA} {mFB} (mFFoldModelF msetX mFA f) mFG
mFFoldModelF-nat msetX mFA mFB mFG f =
  sym (adjNatInD' adjModelF {c = msetX} {d = mFA} {d' = mFB} f mFG)

foldModelF-nat : (msetX : MSet) â†’ (mFA mFB : ModelF)
  â†’ (mFG : catModelF [ mFA , mFB ])
  â†’ (f : catMSet [ msetX , F-ob ftrForgetModelF mFA ])
  â†’ foldModelF msetX mFB (F-hom ftrForgetModelF {x = mFA} {y = mFB} mFG âˆ˜M f)
   â‰¡ (F-hom ftrForgetModelF {x = mFA} {y = mFB} mFG âˆ˜M foldModelF msetX mFA f)
foldModelF-nat msetX mFA mFB mFG f i = mFFoldModelF-nat msetX mFA mFB mFG f i .carrierHom

mFFoldModelF-uniq : (msetX : MSet) â†’ (mFA : ModelF)
  â†’ (f : catMSet [ msetX , F-ob ftrForgetModelF mFA ])
  â†’ (mFG : catModelF [ F-ob ftrFreeModelF msetX , mFA ])
  â†’ (Î» sort â†’ mFG .carrierHom sort âˆ˜ pureTermF sort) â‰¡ f
  â†’ mFFoldModelF msetX mFA f â‰¡ mFG
mFFoldModelF-uniq msetX mFA f mFG ef =
  mFFoldModelF msetX mFA f
    â‰¡âŸ¨âŸ©
  _â™¯ adjModelF {c = msetX} {d = mFA} f
    â‰¡âŸ¨ cong (_â™¯ adjModelF {c = msetX} {d = mFA}) (sym ef) âŸ©
  _â™¯ adjModelF {c = msetX} {d = mFA} (Î» sort â†’ mFG .carrierHom sort âˆ˜ pureTermF sort)
    â‰¡âŸ¨âŸ©
  _â™¯ adjModelF {c = msetX} {d = mFA} (_â™­ adjModelF {c = msetX} {d = mFA} mFG)
    â‰¡âŸ¨ adjModelF .adjIso {c = msetX} {d = mFA} .leftInv mFG âŸ©
  mFG âˆ

foldModelF-uniq : (msetX : MSet) â†’ (mFA : ModelF)
  â†’ (f : catMSet [ msetX , F-ob ftrForgetModelF mFA ])
  â†’ (mFG : catModelF [ F-ob ftrFreeModelF msetX , mFA ])
  â†’ (Î» sort â†’ mFG .carrierHom sort âˆ˜ pureTermF sort) â‰¡ f
  â†’ foldModelF msetX mFA f â‰¡ mFG .carrierHom
foldModelF-uniq msetX mFA f mFG ef i = mFFoldModelF-uniq msetX mFA f mFG ef i .carrierHom

foldModelF-uniq2 : (msetX : MSet) â†’ (mFA : ModelF)
  â†’ (mFG mFH : catModelF [ F-ob ftrFreeModelF msetX , mFA ])
  â†’ (Î» (sort : Sort) â†’ mFG .carrierHom sort âˆ˜ pureTermF sort)
   â‰¡ (Î» (sort : Sort) â†’ mFH .carrierHom sort âˆ˜ pureTermF sort)
  â†’ mFG .carrierHom â‰¡ mFH .carrierHom
foldModelF-uniq2 msetX mFA mFG mFH e =
  mFG .carrierHom
    â‰¡âŸ¨ sym (foldModelF-uniq msetX mFA (Î» sort â†’ mFG .carrierHom sort âˆ˜ pureTermF sort) mFG refl) âŸ©
  foldModelF msetX mFA (Î» sort â†’ mFG .carrierHom sort âˆ˜ pureTermF sort)
    â‰¡âŸ¨ foldModelF-uniq msetX mFA (Î» sort â†’ mFG .carrierHom sort âˆ˜ pureTermF sort) mFH (sym e) âŸ©
  mFH .carrierHom âˆ

-- Sending models of Term1 to models of TermF
module _ where
  {-# TERMINATING #-}
  model1â†’F-algStr : ((algebra msetA Î±) : Model1) â†’ IsAlgebra ftrTermF msetA
  model1â†’F-algStr (algebra msetA Î±) sort (varF a) = a
  model1â†’F-algStr (algebra msetA Î±) sort (join1F t) =
    Î± sort (mapTerm1 (model1â†’F-algStr (algebra msetA Î±)) sort t)
    --Î± sort (term1 o Î» p â†’ model1â†’F-algStr (algebra msetA Î±) (arity o ! p) (args p))

  {-# TERMINATING #-}
  model1â†’F-str-Î¼ :  (m1a : Model1)
    â†’ model1â†’F-algStr m1a âˆ˜M joinTermF
     â‰¡ model1â†’F-algStr m1a âˆ˜M mapTermF (model1â†’F-algStr m1a)
  model1â†’F-str-Î¼ m1a = {!!}

  {-# TERMINATING #-}
  model1â†’F-algStr-joinTermF :
    ((algebra msetA Î±) : Model1) â†’
    âˆ€ sort â†’
    (tta : TermF (TermF (mtyp msetA)) sort) â†’
    model1â†’F-algStr (algebra msetA Î±) sort (joinTermF sort tta) â‰¡
    model1â†’F-algStr (algebra msetA Î±) sort (mapTermF (model1â†’F-algStr (algebra msetA Î±)) sort tta)
  model1â†’F-algStr-joinTermF algA@(algebra msetA Î±) sort (varF ta) = refl
  model1â†’F-algStr-joinTermF algA@(algebra msetA Î±) sort (join1F t) =
    congS (Î± sort) (((
      (Î» sort' â†’ mapTerm1 (model1â†’F-algStr algA) sort' âˆ˜ mapTerm1 joinTermF sort')
        â‰¡âŸ¨ sym (mapTerm1-âˆ˜ (model1â†’F-algStr algA) joinTermF) âŸ©
      mapTerm1 (Î» sortâ‚ â†’ model1â†’F-algStr algA sortâ‚ âˆ˜ joinTermF sortâ‚)
        â‰¡âŸ¨ cong mapTerm1 (funExt Î» sort' â†’ funExt Î» tta â†’ model1â†’F-algStr-joinTermF algA sort' tta) âŸ©
      mapTerm1 (Î» sort' â†’ model1â†’F-algStr algA sort' âˆ˜ mapTermF (model1â†’F-algStr algA) sort')
        â‰¡âŸ¨ mapTerm1-âˆ˜ (model1â†’F-algStr algA) (mapTermF (model1â†’F-algStr algA)) âŸ©
      (Î» sortâ‚ â†’ mapTerm1 (model1â†’F-algStr algA) sortâ‚ âˆ˜ mapTerm1 (mapTermF (model1â†’F-algStr algA)) sortâ‚) âˆ
    ) â‰¡$ sort) â‰¡$S t)

  model1â†’F : Model1 â†’ ModelF
  carrier (fst (model1â†’F (algebra msetA Î±))) = msetA
  algStr (fst (model1â†’F (algebra msetA Î±))) = model1â†’F-algStr (algebra msetA Î±)
  str-Î· (snd (model1â†’F (algebra msetA Î±))) = refl
  str-Î¼ (snd (model1â†’F (algebra msetA Î±))) =
    funExt Î» sort â†’ funExt Î» tta â†’ model1â†’F-algStr-joinTermF (algebra msetA Î±) sort tta

  {-# TERMINATING #-}
  model1â†’F-ishom : âˆ€ {(algebra msetA Î±) (algebra msetB Î²) : Algebra ftrTerm1} â†’ ((algebraHom f isalgF)
    : Model1Hom (algebra msetA Î±) (algebra msetB Î²)) â†’ âˆ€ sort ta
    â†’ f sort (model1â†’F-algStr (algebra msetA Î±) sort ta) â‰¡ model1â†’F-algStr (algebra msetB Î²) sort (mapTermF f sort ta)
  model1â†’F-ishom {algebra msetA Î±} {algebra msetB Î²} (algebraHom f commut) sort (varF a) = refl
  model1â†’F-ishom {algebra msetA Î±} {algebra msetB Î²} (algebraHom f commut) sort (join1F t) = ((
      (Î» sort' â†’ f sort' âˆ˜ Î± sort' âˆ˜ mapTerm1 (model1â†’F-algStr (algebra msetA Î±)) sort')
        â‰¡âŸ¨ cong (Î» h sort' â†’ h sort' âˆ˜ mapTerm1 (model1â†’F-algStr (algebra msetA Î±)) sort') commut âŸ©
      (Î» sort' â†’ Î² sort' âˆ˜ mapTerm1 f sort' âˆ˜ mapTerm1 (model1â†’F-algStr (algebra msetA Î±)) sort')
        â‰¡âŸ¨ congS (Î» h sort' â†’ Î² sort' âˆ˜ h sort') (sym (mapTerm1-âˆ˜ f (model1â†’F-algStr (algebra msetA Î±)))) âŸ©
      (Î» sort' â†’ Î² sort' âˆ˜ mapTerm1 (Î» sortâ‚ â†’ f sortâ‚ âˆ˜ model1â†’F-algStr (algebra msetA Î±) sortâ‚) sort' )
        â‰¡âŸ¨ congS (Î» h sort' â†’ Î² sort' âˆ˜ h sort')
            (congS mapTerm1 (funExt Î» sort'' â†’ funExt Î» ta â†’
              model1â†’F-ishom {algebra msetA Î±} {algebra msetB Î²} (algebraHom f commut) sort'' ta)) âŸ©
      (Î» sort' â†’ Î² sort' âˆ˜ mapTerm1 (Î» sort'' â†’ model1â†’F-algStr (algebra msetB Î²) sort'' âˆ˜ mapTermF f sort'') sort')
        â‰¡âŸ¨ congS (Î» h sort' â†’ Î² sort' âˆ˜ h sort') (mapTerm1-âˆ˜ (model1â†’F-algStr (algebra msetB Î²)) (mapTermF f)) âŸ©
      (Î» sort' â†’ Î² sort' âˆ˜ mapTerm1 (model1â†’F-algStr (algebra msetB Î²)) sort' âˆ˜ mapTerm1 (mapTermF f) sort') âˆ
    ) â‰¡$ sort) â‰¡$S t

  model1â†’F-hom : âˆ€ {m1A m1B} â†’ (m1F : Model1Hom m1A m1B) â†’ ModelFHom (model1â†’F m1A) (model1â†’F m1B)
  carrierHom (model1â†’F-hom {algebra msetA Î±} {algebra msetB Î²} (algebraHom f commut)) = f
  strHom (model1â†’F-hom {algebra msetA Î±} {algebra msetB Î²} (algebraHom f commut)) =
    funExt Î» sort â†’ funExt Î» ta â†’ model1â†’F-ishom (algebraHom f commut) sort ta

  ftrModel1â†’F : Functor catModel1 catModelF
  F-ob ftrModel1â†’F = model1â†’F
  F-hom ftrModel1â†’F = model1â†’F-hom
  F-id ftrModel1â†’F = AlgebraHomâ‰¡ ftrTermF refl
  F-seq ftrModel1â†’F algF algG = AlgebraHomâ‰¡ ftrTermF refl

-- sending models of TermF to models of Term1
module _ where
  nt1â†’F : NatTrans ftrTerm1 ftrTermF
  N-ob nt1â†’F msetA sort t = join1F (mapTerm1 pureTermF sort t)
  N-hom nt1â†’F f =
    (Î» sort' â†’ join1F âˆ˜ mapTerm1 pureTermF sort' âˆ˜ mapTerm1 f sort')
      â‰¡âŸ¨ congS (Î» h sort' â†’ join1F âˆ˜ h sort') (
        (Î» sort' â†’ mapTerm1 pureTermF sort' âˆ˜ mapTerm1 f sort')
          â‰¡âŸ¨ sym (mapTerm1-âˆ˜ pureTermF f) âŸ©
        mapTerm1 (Î» sort' â†’ pureTermF sort' âˆ˜ f sort')
          â‰¡âŸ¨âŸ©
        mapTerm1 (Î» sort â†’ mapTermF f sort âˆ˜ pureTermF sort)
          â‰¡âŸ¨ mapTerm1-âˆ˜ (mapTermF f) pureTermF âŸ©
        (Î» sort' â†’ mapTerm1 (mapTermF f) sort' âˆ˜ mapTerm1 pureTermF sort') âˆ
      ) âŸ©
    (Î» sort' â†’ join1F âˆ˜ mapTerm1 (mapTermF f) sort' âˆ˜ mapTerm1 pureTermF sort')
      â‰¡âŸ¨âŸ©
    (Î» sort' â†’ mapTermF f sort' âˆ˜ join1F âˆ˜ mapTerm1 pureTermF sort') âˆ

  ftrModelFâ†’1 : Functor catModelF catModel1
  ftrModelFâ†’1 = funcComp {-{D = AlgebrasCategory ftrTermF}{E = catModel1}{C = catModelF}-}
    (AlgebrasFunctor {F = ftrTerm1} {G = ftrTermF} nt1â†’F)
    (ForgetEM monadTermF)

  modelFâ†’1 : ModelF â†’ Model1
  modelFâ†’1 = F-ob ftrModelFâ†’1

-- Isomorphism components of Model1 â†” ModelF
module _ where
  ftrModel1â†’Fâ†’1 : funcComp ftrModelFâ†’1 ftrModel1â†’F â‰¡ ftrId catModel1
  ftrModel1â†’Fâ†’1 = Functorâ‰¡
    (Î» where
      (algebra msetA Î±) â†’ congâ‚‚ algebra refl (
          (Î» sort' â†’ model1â†’F-algStr (algebra msetA Î±) sort' âˆ˜ join1F âˆ˜ mapTerm1 pureTermF sort')
            â‰¡âŸ¨âŸ©
          (Î» sort' â†’ Î± sort' âˆ˜ mapTerm1 (model1â†’F-algStr (algebra msetA Î±)) sort' âˆ˜ mapTerm1 pureTermF sort')
            â‰¡âŸ¨ congS (Î» h sort' â†’ Î± sort' âˆ˜ h sort') (
              (Î» sort' â†’ mapTerm1 (model1â†’F-algStr (algebra msetA Î±)) sort' âˆ˜ mapTerm1 pureTermF sort')
                â‰¡âŸ¨ sym (mapTerm1-âˆ˜ _ _) âŸ©
              mapTerm1 (Î» sort â†’ model1â†’F-algStr (algebra msetA Î±) sort âˆ˜ pureTermF sort)
                â‰¡âŸ¨âŸ©
              mapTerm1 (Î» sort â†’ idfun _)
                â‰¡âŸ¨ mapTerm1-id âŸ©
              (Î» sort â†’ idfun _) âˆ
            ) âŸ©
          Î± âˆ
        )
    )
    (Î» where
      {algebra msetA Î±} {algebra msetB Î²} (algebraHom f isalgF) â†’ AlgebraHomPathP ftrTerm1 refl
    )

  {-# TERMINATING #-}
  ftrModelFâ†’1â†’F : funcComp ftrModel1â†’F ftrModelFâ†’1 â‰¡ ftrId catModelF
  ftrModelFâ†’1â†’F = Functorâ‰¡
    (Î» where
      (algebra msetA Î± , isEMA) â†’ Î£â‰¡Prop
        (Î» algA â†’ isPropIsEMAlgebra monadTermF)
        (cong (algebra msetA) (funExt Î» sort â†’ funExt Î» ta â†’ lemma (algebra msetA Î±) isEMA sort ta))
    )
    (Î» where
      {algebra msetA Î± , isEMA} {algebra msetB Î² , isEMB} (algebraHom f isalgF) â†’
        AlgebraHomPathP ftrTermF refl
    )
    where
      open IsEMAlgebra
      lemma : âˆ€ ((algebra msetA Î±) : Algebra ftrTermF) (isEMA : IsEMAlgebra monadTermF (algebra msetA Î±))
        (sort : Sort) (ta : TermF (Î» sortâ‚ â†’ fst (msetA sortâ‚)) sort) â†’
        model1â†’F-algStr (algebra msetA (Î» sort' â†’ Î± sort' âˆ˜ join1F âˆ˜ mapTerm1 pureTermF sort')) sort ta
        â‰¡ Î± sort ta
      lemma (algebra msetA Î±) isEMA sort (varF a) = sym ((str-Î· isEMA â‰¡$ sort) â‰¡$ a)
      lemma (algebra msetA Î±) isEMA sort (join1F t) = ((
          (Î» sort' â†’ Î± sort' âˆ˜ join1F âˆ˜ mapTerm1 pureTermF sort' âˆ˜
            mapTerm1 (model1â†’F-algStr (algebra msetA (Î» sort' â†’ Î± sort' âˆ˜ join1F âˆ˜ mapTerm1 pureTermF sort'))) sort')
            â‰¡âŸ¨ congS (Î» h sort' â†’ Î± sort' âˆ˜ join1F âˆ˜ mapTerm1 pureTermF sort' âˆ˜ h sort')
                 (cong mapTerm1 (funExt Î» sort' â†’ funExt Î» ta â†’ lemma (algebra msetA Î±) isEMA sort' ta)) âŸ©
          (Î» sort' â†’ Î± sort' âˆ˜ join1F âˆ˜ mapTerm1 pureTermF sort' âˆ˜ mapTerm1 Î± sort')
            â‰¡âŸ¨ congS (Î» h sort' â†’ Î± sort' âˆ˜ join1F âˆ˜ h sort') (sym (mapTerm1-âˆ˜ pureTermF Î±)) âŸ©
          (Î» sort' â†’ Î± sort' âˆ˜ join1F âˆ˜ mapTerm1 (Î» sortâ‚ â†’ pureTermF sortâ‚ âˆ˜ Î± sortâ‚) sort')
            â‰¡âŸ¨âŸ©
          (Î» sort' â†’ Î± sort' âˆ˜ join1F âˆ˜ mapTerm1 (Î» sortâ‚ â†’ mapTermF Î± sortâ‚ âˆ˜ pureTermF sortâ‚) sort')
            â‰¡âŸ¨ congS (Î» h sort' â†’ Î± sort' âˆ˜ join1F âˆ˜ h sort') (mapTerm1-âˆ˜ (mapTermF Î±) pureTermF) âŸ©
          (Î» sort' â†’ Î± sort' âˆ˜ join1F âˆ˜ mapTerm1 (mapTermF Î±) sort' âˆ˜ mapTerm1 pureTermF sort')
            â‰¡âŸ¨âŸ©
          (Î» sort' â†’ Î± sort' âˆ˜ mapTermF Î± sort' âˆ˜ join1F âˆ˜ mapTerm1 pureTermF sort')
            â‰¡âŸ¨ congS (Î» h sort' â†’ h sort' âˆ˜ join1F âˆ˜ mapTerm1 pureTermF sort') (sym (str-Î¼ isEMA)) âŸ©
          (Î» sort' â†’ Î± sort' âˆ˜ joinTermF sort' âˆ˜ join1F âˆ˜ mapTerm1 pureTermF sort')
            â‰¡âŸ¨âŸ©
          (Î» sort' â†’ Î± sort' âˆ˜ join1F âˆ˜ mapTerm1 joinTermF sort' âˆ˜ mapTerm1 pureTermF sort')
            â‰¡âŸ¨ congS (Î» h sort' â†’ Î± sort' âˆ˜ join1F âˆ˜ h sort') (sym (mapTerm1-âˆ˜ joinTermF pureTermF)) âŸ©
          (Î» sort' â†’ Î± sort' âˆ˜ join1F âˆ˜ mapTerm1 (Î» sort'' â†’ idfun _) sort')
            â‰¡âŸ¨ congS (Î» h sort' â†’ Î± sort' âˆ˜ join1F âˆ˜ h sort') mapTerm1-id âŸ©
          (Î» sort' â†’ Î± sort' âˆ˜ join1F) âˆ
        ) â‰¡$ sort) â‰¡$S t

-- Model1 â‰… ModelF
open PrecatIso
isoftrModel1â‰…F : PrecatIso (CatPrecategory â„“-zero â„“-zero) catModel1 catModelF
mor isoftrModel1â‰…F = ftrModel1â†’F
inv isoftrModel1â‰…F = ftrModelFâ†’1
sec isoftrModel1â‰…F = ftrModelFâ†’1â†’F
ret isoftrModel1â‰…F = ftrModel1â†’Fâ†’1

-- SyntaxQ object
module _ where

  mFSyntaxF : ModelF
  mFSyntaxF = F-ob ftrFreeModelF msetEmpty

  open NaturalBijection

  isInitial-mFSyntaxF : isInitial catModelF mFSyntaxF
  isInitial-mFSyntaxF = isLeftAdjointâ†’preservesInitial
    {C = catMSet}
    {D = catModelF}
    ftrFreeModelF
    (ftrForgetModelF , emAdjunction monadTermF)
    msetEmpty
    isInitial-msetEmpty

  m1SyntaxF : Model1
  m1SyntaxF = F-ob ftrModelFâ†’1 mFSyntaxF

  {- Ways to prove initiality of m1SyntaxF:
     - directly (seems stupid)
     - prove that isomorphic precategories are equal
     - prove that mutually inverse functors are adjoint
  -}
