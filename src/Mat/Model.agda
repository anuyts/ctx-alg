{-# OPTIONS --cubical --type-in-type #-}

open import Cubical.Foundations.Prelude
open import Cubical.Foundations.Function
open import Cubical.Foundations.Isomorphism renaming (Iso to _â‰…_)
open import Cubical.Foundations.HLevels
open import Cubical.Data.List.FinData renaming (lookup to _!_)
open import Cubical.Data.Sigma
open import Cubical.Foundations.Structure hiding (str)
open import Cubical.Categories.Category
import Cubical.Categories.Category.Precategory as P
open import Cubical.Categories.Functor renaming (ğŸ™âŸ¨_âŸ© to funcId)
open import Cubical.Categories.NaturalTransformation
open import Cubical.Categories.Monad.Base
open import Cubical.Categories.Instances.FunctorAlgebras
open import Cubical.Categories.Instances.EilenbergMoore
open import Cubical.Categories.Instances.Categories
open import Cubical.Categories.Adjoint
open import Cubical.Categories.Constructions.FullSubcategory
open import Cubical.Categories.Limits.Initial

open import Mat.Signature
open import Mat.Free.Presentation
import Mat.Free.TermQ
import Mat.Free.ModelQ
import Mat.TermQ
open import Mat.Presentation

-- TermQs of the MAT generated by a MAT presentation
module Mat.ModelQ {sign : Signature} (mat : Mat sign) where

open Signature sign
open Mat
open FreeMat (getFreeMat mat)
open Mat.Free.TermQ (getFreeMat mat)
open Mat.Free.ModelQ (getFreeMat mat)
open EqTheory (getEqTheory mat)
open Mat.TermQ mat

open Category hiding (_âˆ˜_)
open Functor
open Algebra
open IsMonad
open NatTrans
open IsEMAlgebra
open NaturalBijection
open _âŠ£_
open AlgebraHom
open _â‰…_
private
  module Pâ‰… = P.PrecatIso

-- ModelQs are Eilenberg-Moore algebras of monadTermQ
catModelQ : Category â„“-zero â„“-zero
catModelQ = EMCategory monadTermQ

ModelQ : Type
ModelQ = ob catModelQ

ModelQHom : (mA mB : ModelQ) â†’ Type
ModelQHom = Hom[_,_] catModelQ

-- Forgetful functor sending models to their carrier
ftrForgetModelQ : Functor catModelQ catMSet
ftrForgetModelQ = ForgetEMAlgebra monadTermQ

-- Free model functor
ftrFreeModelQ : Functor catMSet catModelQ
ftrFreeModelQ = FreeEMAlgebra monadTermQ

adjModelQ : ftrFreeModelQ âŠ£ ftrForgetModelQ
adjModelQ = emAdjunction monadTermQ

-- Recursion/folding (with metavariables) and properties

mFoldModelQ : (msetX : MSet) â†’ (mA : ModelQ)
  â†’ catMSet [ msetX , F-ob ftrForgetModelQ mA ]
  â†’ catModelQ [ F-ob ftrFreeModelQ msetX , mA ]
mFoldModelQ msetX mA = _â™¯ adjModelQ {c = msetX} {d = mA}

foldModelQ : (msetX : MSet) â†’ (mA : ModelQ)
  â†’ catMSet [ msetX , F-ob ftrForgetModelQ mA ]
  â†’ âˆ€ sort â†’ TermQ (mtyp msetX) sort â†’ typ (carrier (fst mA) sort)
foldModelQ msetX mA f = mFoldModelQ msetX mA f .carrierHom

mFoldModelQ-nat :  (msetX : MSet) â†’ (mA mB : ModelQ)
  â†’ (mG : catModelQ [ mA , mB ])
  â†’ (f : catMSet [ msetX , F-ob ftrForgetModelQ mA ])
  â†’ mFoldModelQ msetX mB (_â‹†_
      catMSet
      {x = msetX}
      {y = F-ob ftrForgetModelQ mA}
      {z = F-ob ftrForgetModelQ mB}
      f
      (F-hom ftrForgetModelQ {x = mA} {y = mB} mG)
    )
  â‰¡ _â‹†_ catModelQ {x = F-ob ftrFreeModelQ msetX} {mA} {mB} (mFoldModelQ msetX mA f) mG
mFoldModelQ-nat msetX mA mB mG f =
  sym (adjNatInD' adjModelQ {c = msetX} {d = mA} {d' = mB} f mG)

foldModelQ-nat : (msetX : MSet) â†’ (mA mB : ModelQ)
  â†’ (mG : catModelQ [ mA , mB ])
  â†’ (f : catMSet [ msetX , F-ob ftrForgetModelQ mA ])
  â†’ foldModelQ msetX mB (Î» sort â†’ F-hom ftrForgetModelQ {x = mA} {y = mB} mG sort âˆ˜ f sort)
   â‰¡ (Î» sort â†’ F-hom ftrForgetModelQ {x = mA} {y = mB} mG sort âˆ˜ foldModelQ msetX mA f sort)
foldModelQ-nat msetX mA mB mG f i = mFoldModelQ-nat msetX mA mB mG f i .carrierHom

mFoldModelQ-uniq : (msetX : MSet) â†’ (mA : ModelQ)
  â†’ (f : catMSet [ msetX , F-ob ftrForgetModelQ mA ])
  â†’ (mG : catModelQ [ F-ob ftrFreeModelQ msetX , mA ])
  â†’ (Î» sort â†’ mG .carrierHom sort âˆ˜ pureTermQ sort) â‰¡ f
  â†’ mFoldModelQ msetX mA f â‰¡ mG
mFoldModelQ-uniq msetX mA f mG ef =
  mFoldModelQ msetX mA f
    â‰¡âŸ¨âŸ©
  _â™¯ adjModelQ {c = msetX} {d = mA} f
    â‰¡âŸ¨ cong (_â™¯ adjModelQ {c = msetX} {d = mA}) (sym ef) âŸ©
  _â™¯ adjModelQ {c = msetX} {d = mA} (Î» sort â†’ mG .carrierHom sort âˆ˜ pureTermQ sort)
    â‰¡âŸ¨âŸ©
  _â™¯ adjModelQ {c = msetX} {d = mA} (_â™­ adjModelQ {c = msetX} {d = mA} mG)
    â‰¡âŸ¨ adjModelQ .adjIso {c = msetX} {d = mA} .leftInv mG âŸ©
  mG âˆ

foldModelQ-uniq : (msetX : MSet) â†’ (mA : ModelQ)
  â†’ (f : catMSet [ msetX , F-ob ftrForgetModelQ mA ])
  â†’ (mG : catModelQ [ F-ob ftrFreeModelQ msetX , mA ])
  â†’ (Î» sort â†’ mG .carrierHom sort âˆ˜ pureTermQ sort) â‰¡ f
  â†’ foldModelQ msetX mA f â‰¡ mG .carrierHom
foldModelQ-uniq msetX mA f mG ef i = mFoldModelQ-uniq msetX mA f mG ef i .carrierHom

foldModelQ-uniq2 : (msetX : MSet) â†’ (mA : ModelQ)
  â†’ (mG mH : catModelQ [ F-ob ftrFreeModelQ msetX , mA ])
  â†’ (Î» (sort : Sort) â†’ mG .carrierHom sort âˆ˜ pureTermQ sort)
   â‰¡ (Î» (sort : Sort) â†’ mH .carrierHom sort âˆ˜ pureTermQ sort)
  â†’ mG .carrierHom â‰¡ mH .carrierHom
foldModelQ-uniq2 msetX mA mG mH e =
  mG .carrierHom
    â‰¡âŸ¨ sym (foldModelQ-uniq msetX mA (Î» sort â†’ mG .carrierHom sort âˆ˜ pureTermQ sort) mG refl) âŸ©
  foldModelQ msetX mA (Î» sort â†’ mG .carrierHom sort âˆ˜ pureTermQ sort)
    â‰¡âŸ¨ foldModelQ-uniq msetX mA (Î» sort â†’ mG .carrierHom sort âˆ˜ pureTermQ sort) mH (sym e) âŸ©
  mH .carrierHom âˆ

-- catModelQ as a full subcategory of catModelF and catModel1

-- catModelFEq and catModel1Eq
respectsEqTheoryF : ModelF â†’ Type
respectsEqTheoryF mA = âˆ€ {sort} â†’ (axiom : Axiom sort)
  â†’ (f : âˆ€ sort' â†’ mtyp (msetArity axiom) sort' â†’ mtyp (mA .fst .carrier) sort')
  â†’ (mA .fst .str sort âˆ˜ mapTermF f sort) (lhs axiom)
   â‰¡ (mA .fst .str sort âˆ˜ mapTermF f sort) (rhs axiom)

isProp-respectsEqTheoryF : (mFA : ModelF) â†’ isProp (respectsEqTheoryF mFA)
isProp-respectsEqTheoryF mFA =
  isPropImplicitÎ  Î» sort â†’ isPropÎ  Î» axiom â†’ isPropÎ  Î» f â†’
    mFA .fst .carrier sort .snd _ _

catModelFEq : Category â„“-zero â„“-zero
catModelFEq = FullSubcategory catModelF respectsEqTheoryF

ModelFEq : Type
ModelFEq = ob catModelFEq

ModelFEqHom : (mFEqA mFEqB : ModelFEq) â†’ Type
ModelFEqHom = Hom[_,_] catModelFEq

respectsEqTheory1 : Model1 â†’ Type
respectsEqTheory1 m1A = respectsEqTheoryF (model1â†’F m1A)

isProp-respectsEqTheory1 : (m1A : Model1) â†’ isProp (respectsEqTheory1 m1A)
isProp-respectsEqTheory1 m1A = isProp-respectsEqTheoryF (model1â†’F m1A)

catModel1Eq : Category â„“-zero â„“-zero
catModel1Eq = FullSubcategory catModel1 respectsEqTheory1

Model1Eq : Type
Model1Eq = ob catModel1Eq

Model1EqHom : (m1EqA m1EqB : Model1Eq) â†’ Type
Model1EqHom = Hom[_,_] catModel1Eq

--------------

respectsEqTheory1â†’F : (m1A : Model1) â†’ respectsEqTheory1 m1A â†’ respectsEqTheoryF (model1â†’F m1A)
respectsEqTheory1â†’F m1A respectsEqTheory1A = respectsEqTheory1A

ftrModel1Eqâ†’FEq : Functor catModel1Eq catModelFEq
ftrModel1Eqâ†’FEq = MapFullSubcategory
  catModel1 respectsEqTheory1
  catModelF respectsEqTheoryF
  ftrModel1â†’F respectsEqTheory1â†’F

model1Eqâ†’FEq : Model1Eq â†’ ModelFEq
model1Eqâ†’FEq = F-ob ftrModel1Eqâ†’FEq

respectsEqTheoryFâ†’1 : (mFA : ModelF) â†’ respectsEqTheoryF mFA â†’ respectsEqTheory1 (modelFâ†’1 mFA)
respectsEqTheoryFâ†’1 mFA respectsEqTheoryFA = subst
  respectsEqTheoryF
  (cong (Î» F â†’ F-ob F mFA) (sym ftrModelFâ†’1â†’F))
  respectsEqTheoryFA

ftrModelFEqâ†’1Eq : Functor catModelFEq catModel1Eq
ftrModelFEqâ†’1Eq = MapFullSubcategory
  catModelF respectsEqTheoryF
  catModel1 respectsEqTheory1
  ftrModelFâ†’1 respectsEqTheoryFâ†’1

modelFEqâ†’1Eq : ModelFEq â†’ Model1Eq
modelFEqâ†’1Eq = F-ob ftrModelFEqâ†’1Eq

ftrModel1Eqâ†’FEqâ†’1Eq : funcComp ftrModelFEqâ†’1Eq ftrModel1Eqâ†’FEq â‰¡ funcId catModel1Eq
ftrModel1Eqâ†’FEqâ†’1Eq =
  funcComp ftrModelFEqâ†’1Eq ftrModel1Eqâ†’FEq
    â‰¡âŸ¨ sym (MapFullSubcategory-seq _ _ _ _ _ _ _ _ _ _) âŸ©
  MapFullSubcategory
      catModel1 respectsEqTheory1
      catModel1 respectsEqTheory1
      (funcComp ftrModelFâ†’1 ftrModel1â†’F)
      (Î» c p â†’ respectsEqTheoryFâ†’1 (F-ob ftrModel1â†’F c) (respectsEqTheory1â†’F c p))
    â‰¡âŸ¨ congâ‚‚ (MapFullSubcategory catModel1 respectsEqTheory1 catModel1 respectsEqTheory1)
         ftrModel1â†’Fâ†’1
         (toPathP (funExt Î» m1A â†’ funExt Î» respectsEqTheory1A â†’ isProp-respectsEqTheory1 m1A _ _))
    âŸ©
  MapFullSubcategory catModel1 respectsEqTheory1 catModel1 respectsEqTheory1 (funcId catModel1) (Î» c p â†’ p)
    â‰¡âŸ¨ MapFullSubcategory-id _ _ âŸ©
  funcId catModel1Eq âˆ

ftrModelFEqâ†’1Eqâ†’FEq : funcComp ftrModel1Eqâ†’FEq ftrModelFEqâ†’1Eq â‰¡ funcId catModelFEq
ftrModelFEqâ†’1Eqâ†’FEq =
  funcComp ftrModel1Eqâ†’FEq ftrModelFEqâ†’1Eq
    â‰¡âŸ¨ sym (MapFullSubcategory-seq _ _ _ _ _ _ _ _ _ _) âŸ©
  MapFullSubcategory
      catModelF respectsEqTheoryF
      catModelF respectsEqTheoryF
      (funcComp ftrModel1â†’F ftrModelFâ†’1)
      (Î» c p â†’ respectsEqTheory1â†’F (F-ob ftrModelFâ†’1 c) (respectsEqTheoryFâ†’1 c p))
    â‰¡âŸ¨ congâ‚‚ (MapFullSubcategory catModelF respectsEqTheoryF catModelF respectsEqTheoryF)
         ftrModelFâ†’1â†’F
         (toPathP (funExt Î» mFA â†’ funExt Î» respectsEqTheoryFA â†’ isProp-respectsEqTheoryF mFA _ _))
    âŸ©
  MapFullSubcategory catModelF respectsEqTheoryF catModelF respectsEqTheoryF (funcId catModelF) (Î» c p â†’ p)
    â‰¡âŸ¨ MapFullSubcategory-id _ _ âŸ©
  funcId catModelFEq âˆ

isoftrModel1Eqâ‰…FEq : P.PrecatIso (CatPrecategory â„“-zero â„“-zero) catModel1Eq catModelFEq
Pâ‰….mor isoftrModel1Eqâ‰…FEq = ftrModel1Eqâ†’FEq
Pâ‰….inv isoftrModel1Eqâ‰…FEq = ftrModelFEqâ†’1Eq
Pâ‰….sec isoftrModel1Eqâ‰…FEq = ftrModelFEqâ†’1Eqâ†’FEq
Pâ‰….ret isoftrModel1Eqâ‰…FEq = ftrModel1Eqâ†’FEqâ†’1Eq

--------------

-- catModel1Eq â†’ catModelQ

{-# TERMINATING #-}
model1Eqâ†’Q-algStr : (m1EqA : Model1Eq) â†’ IsAlgebra ftrTermQ (m1EqA .fst .carrier)
model1Eqâ†’Q-algStr m1EqA@(algebra msetA Î±1 , respectsEqA) sort (var x) = x
model1Eqâ†’Q-algStr m1EqA@(algebra msetA Î±1 , respectsEqA) sort (ast t) =
  Î±1 sort (mapTerm1 (model1Eqâ†’Q-algStr m1EqA) sort t)
model1Eqâ†’Q-algStr m1EqA@(algebra msetA Î±1 , respectsEqA) sort (joinFQ t) =
  Î±F sort (mapTermF (model1Eqâ†’Q-algStr m1EqA) sort t)
  where Î±F : IsAlgebra ftrTermF msetA
        Î±F = model1â†’F (algebra msetA Î±1) .fst .str
model1Eqâ†’Q-algStr m1EqA@(algebra msetA Î±1 , respectsEqA) sort (joinFQ-varF t i) =
  model1Eqâ†’Q-algStr m1EqA sort t
model1Eqâ†’Q-algStr m1EqA@(algebra msetA Î±1 , respectsEqA) sort (joinFQ-astF t i) =
  Î±1 sort (mapTerm1 (model1Eqâ†’Q-algStr m1EqA) sort (mapTerm1 (Î» sortâ‚ â†’ joinFQ) sort t))
model1Eqâ†’Q-algStr m1EqA@(algebra msetA Î±1 , respectsEqA) sort (byAxiom axiom f i) =
  lemma2 i
  where Î±F : IsAlgebra ftrTermF msetA
        Î±F = model1â†’F (algebra msetA Î±1) .fst .str
        lemma : Î±F sort (mapTermF (Î» sort' â†’ model1Eqâ†’Q-algStr m1EqA sort' âˆ˜ f sort') sort (lhs axiom))
              â‰¡ Î±F sort (mapTermF (Î» sort' â†’ model1Eqâ†’Q-algStr m1EqA sort' âˆ˜ f sort') sort (rhs axiom))
        lemma = respectsEqA axiom Î» sort' â†’ model1Eqâ†’Q-algStr m1EqA sort' âˆ˜ f sort'
        lemma2 : Î±F sort (mapTermF (model1Eqâ†’Q-algStr m1EqA) sort (mapTermF f sort (lhs axiom)))
               â‰¡ Î±F sort (mapTermF (model1Eqâ†’Q-algStr m1EqA) sort (mapTermF f sort (rhs axiom)))
        lemma2 =
          Î±F sort (mapTermF (model1Eqâ†’Q-algStr m1EqA) sort (mapTermF f sort (lhs axiom)))
            â‰¡âŸ¨ sym (cong (Î±F sort) (funExtâ» (funExtâ» (mapTermF-âˆ˜ (model1Eqâ†’Q-algStr m1EqA) f) sort) (lhs axiom))) âŸ©
          Î±F sort (mapTermF (Î» sort' â†’ model1Eqâ†’Q-algStr m1EqA sort' âˆ˜ f sort') sort (lhs axiom))
            â‰¡âŸ¨ lemma âŸ©
          Î±F sort (mapTermF (Î» sort' â†’ model1Eqâ†’Q-algStr m1EqA sort' âˆ˜ f sort') sort (rhs axiom))
            â‰¡âŸ¨ cong (Î±F sort) (funExtâ» (funExtâ» (mapTermF-âˆ˜ (model1Eqâ†’Q-algStr m1EqA) f) sort) (rhs axiom)) âŸ©
          Î±F sort (mapTermF (model1Eqâ†’Q-algStr m1EqA) sort (mapTermF f sort (rhs axiom))) âˆ
model1Eqâ†’Q-algStr m1EqA@(algebra msetA Î±1 , respectsEqA) sort (isSetTermQ t1 t2 et et' i j) = snd (msetA sort)
  (model1Eqâ†’Q-algStr m1EqA sort t1)
  (model1Eqâ†’Q-algStr m1EqA sort t2)
  (Î» i â†’ model1Eqâ†’Q-algStr m1EqA sort (et i))
  (Î» i â†’ model1Eqâ†’Q-algStr m1EqA sort (et' i)) i j

{-# TERMINATING #-}
model1Eqâ†’Q-algStr-joinTermQ : (m1EqA : Model1Eq)
  â†’ (Î» (sort : Sort) â†’ model1Eqâ†’Q-algStr m1EqA sort âˆ˜ joinTermQ sort)
  â‰¡ (Î» (sort : Sort) â†’ model1Eqâ†’Q-algStr m1EqA sort âˆ˜ mapTermQ (model1Eqâ†’Q-algStr m1EqA) sort)
mapTermF-model1Eqâ†’Q-algStr-joinTermQ : (m1EqA : Model1Eq)
  â†’ (Î» (sort : Sort) â†’ mapTermF (model1Eqâ†’Q-algStr m1EqA) sort âˆ˜ mapTermF joinTermQ sort)
  â‰¡ (Î» (sort : Sort) â†’ mapTermF (model1Eqâ†’Q-algStr m1EqA) sort âˆ˜ mapTermF (mapTermQ (model1Eqâ†’Q-algStr m1EqA)) sort)
model1Eqâ†’Q-algStr-joinTermQ m1EqA@(algebra msetA Î±1 , respectsEqA) i sort (var t) =
  model1Eqâ†’Q-algStr m1EqA sort t
model1Eqâ†’Q-algStr-joinTermQ m1EqA@(algebra msetA Î±1 , respectsEqA) i sort (ast t) =
  Î±1 sort (mapTerm1 (model1Eqâ†’Q-algStr-joinTermQ m1EqA i) sort t)
model1Eqâ†’Q-algStr-joinTermQ m1EqA@(algebra msetA Î±1 , respectsEqA) i sort (joinFQ t) =
  Î±F sort (mapTermF-model1Eqâ†’Q-algStr-joinTermQ m1EqA i sort t)
  where Î±F : IsAlgebra ftrTermF msetA
        Î±F = model1â†’F (algebra msetA Î±1) .fst .str
model1Eqâ†’Q-algStr-joinTermQ m1EqA@(algebra msetA Î±1 , respectsEqA) i sort (joinFQ-varF t j) =
  idfun
    (Square
      (Î» j â†’ model1Eqâ†’Q-algStr m1EqA sort (joinTermQ sort t))
      (Î» j â†’ model1Eqâ†’Q-algStr m1EqA sort
               (mapTermQ (model1Eqâ†’Q-algStr m1EqA) sort t))
      (Î» i â†’ Î±F sort (mapTermF-model1Eqâ†’Q-algStr-joinTermQ m1EqA i sort (varF t)))
      (Î» i â†’ model1Eqâ†’Q-algStr-joinTermQ m1EqA i sort t)
    ) (toPathP (snd (msetA sort) _ _ _ _)) i j
  where Î±F : IsAlgebra ftrTermF msetA
        Î±F = model1â†’F (algebra msetA Î±1) .fst .str
model1Eqâ†’Q-algStr-joinTermQ m1EqA@(algebra msetA Î±1 , respectsEqA) i sort (joinFQ-astF t j) =
  idfun
    (Square
      (Î» j â†’ (model1Eqâ†’Q-algStr m1EqA sort âˆ˜ joinTermQ sort) (joinFQ-astF t j))
      (Î» j â†’ (model1Eqâ†’Q-algStr m1EqA sort
                âˆ˜ mapTermQ (model1Eqâ†’Q-algStr m1EqA) sort) (joinFQ-astF t j))
      (Î» i â†’ Î±F sort (mapTermF-model1Eqâ†’Q-algStr-joinTermQ m1EqA i sort (astF t)))
      (Î» i â†’ Î±1 sort (mapTerm1 (model1Eqâ†’Q-algStr-joinTermQ m1EqA i)
                 sort (mapTerm1 (Î» sortâ‚ â†’ joinFQ) sort t)))
    ) (toPathP (snd (msetA sort) _ _ _ _)) i j
  where Î±F : IsAlgebra ftrTermF msetA
        Î±F = model1â†’F (algebra msetA Î±1) .fst .str
model1Eqâ†’Q-algStr-joinTermQ m1EqA@(algebra msetA Î±1 , respectsEqA) i sort (byAxiom axiom f j) =
  idfun
    (Square
      (Î» j â†’ (model1Eqâ†’Q-algStr m1EqA sort âˆ˜ joinTermQ sort) (byAxiom axiom f j))
      (Î» j â†’ (model1Eqâ†’Q-algStr m1EqA sort
               âˆ˜ mapTermQ (model1Eqâ†’Q-algStr m1EqA) sort) (byAxiom axiom f j))
      (Î» i â†’ Î±F sort (mapTermF-model1Eqâ†’Q-algStr-joinTermQ m1EqA i sort (mapTermF f sort (lhs axiom))))
      (Î» i â†’ Î±F sort (mapTermF-model1Eqâ†’Q-algStr-joinTermQ m1EqA i sort (mapTermF f sort (rhs axiom))))
    ) (toPathP (snd (msetA sort) _ _ _ _)) i j
  where Î±F : IsAlgebra ftrTermF msetA
        Î±F = model1â†’F (algebra msetA Î±1) .fst .str
model1Eqâ†’Q-algStr-joinTermQ m1EqA@(algebra msetA Î±1 , respectsEqA) i sort (isSetTermQ t1 t2 et et' j k) = snd (msetA sort)
  (model1Eqâ†’Q-algStr-joinTermQ m1EqA i sort t1)
  (model1Eqâ†’Q-algStr-joinTermQ m1EqA i sort t2)
  (Î» j â†’ model1Eqâ†’Q-algStr-joinTermQ m1EqA i sort (et j))
  (Î» j â†’ model1Eqâ†’Q-algStr-joinTermQ m1EqA i sort (et' j)) j k
mapTermF-model1Eqâ†’Q-algStr-joinTermQ m1EqA =
  (Î» sort â†’ mapTermF (model1Eqâ†’Q-algStr m1EqA) sort âˆ˜ mapTermF joinTermQ sort)
    â‰¡âŸ¨ sym (mapTermF-âˆ˜ (model1Eqâ†’Q-algStr m1EqA) joinTermQ) âŸ©
  mapTermF (Î» sort â†’ model1Eqâ†’Q-algStr m1EqA sort âˆ˜ joinTermQ sort)
    â‰¡âŸ¨ cong mapTermF (model1Eqâ†’Q-algStr-joinTermQ m1EqA) âŸ©
  mapTermF (Î» sort â†’ model1Eqâ†’Q-algStr m1EqA sort âˆ˜ mapTermQ (model1Eqâ†’Q-algStr m1EqA) sort)
    â‰¡âŸ¨ mapTermF-âˆ˜ (model1Eqâ†’Q-algStr m1EqA) (mapTermQ (model1Eqâ†’Q-algStr m1EqA)) âŸ©
  (Î» sort â†’ mapTermF (model1Eqâ†’Q-algStr m1EqA) sort âˆ˜ mapTermF (mapTermQ (model1Eqâ†’Q-algStr m1EqA)) sort) âˆ

model1Eqâ†’Q-isEMAlgebra : (m1EqA : Model1Eq)
  â†’ IsEMAlgebra monadTermQ (algebra (m1EqA .fst .carrier) (model1Eqâ†’Q-algStr m1EqA))
str-Î· (model1Eqâ†’Q-isEMAlgebra m1EqA@(algebra msetA Î±1 , respectsEqA)) = refl
str-Î¼ (model1Eqâ†’Q-isEMAlgebra m1EqA@(algebra msetA Î±1 , respectsEqA)) = model1Eqâ†’Q-algStr-joinTermQ m1EqA

model1Eqâ†’Q : Model1Eq â†’ ModelQ
carrier (fst (model1Eqâ†’Q m1EqA@(algebra msetA Î±1 , respectsEqA))) = msetA
str (fst (model1Eqâ†’Q m1EqA@(algebra msetA Î±1 , respectsEqA))) = model1Eqâ†’Q-algStr m1EqA
snd (model1Eqâ†’Q m1EqA@(algebra msetA Î±1 , respectsEqA)) = model1Eqâ†’Q-isEMAlgebra m1EqA

{-# TERMINATING #-}
ModelQHom1Eqâ†’IsTermQAlgebraHom' : âˆ€ m1EqA m1EqB â†’ (m1EqF : Model1EqHom m1EqA m1EqB) â†’
      (sort : Sort) (t : TermQ (mtyp (m1EqA .fst .carrier)) sort) â†’
      carrierHom m1EqF sort (model1Eqâ†’Q-algStr m1EqA sort t)
      â‰¡ model1Eqâ†’Q-algStr m1EqB sort (mapTermQ (carrierHom m1EqF) sort t)
mapTermF-ModelQHom1Eqâ†’IsTermQAlgebraHom' : âˆ€ m1EqA m1EqB â†’ (m1EqF : Model1EqHom m1EqA m1EqB) â†’
      (sort : Sort) (t : TermF (TermQ (mtyp (m1EqA .fst .carrier))) sort) â†’
      carrierHom m1EqF sort (model1â†’F-algStr (m1EqA .fst) sort (mapTermF (model1Eqâ†’Q-algStr m1EqA) sort t))
      â‰¡ model1â†’F-algStr (m1EqB .fst) sort
        (mapTermF (model1Eqâ†’Q-algStr m1EqB) sort (mapTermF (mapTermQ (carrierHom m1EqF)) sort t))
ModelQHom1Eqâ†’IsTermQAlgebraHom' m1EqA m1EqB m1EqF@(algebraHom f f-isalg1) sort (var x) = refl
ModelQHom1Eqâ†’IsTermQAlgebraHom' m1EqA m1EqB m1EqF@(algebraHom f f-isalg1) sort (ast t) =
  f sort (str (fst m1EqA) sort (mapTerm1 (model1Eqâ†’Q-algStr m1EqA) sort t))
    â‰¡âŸ¨ funExtâ» (funExtâ» f-isalg1 sort) (mapTerm1 (model1Eqâ†’Q-algStr m1EqA) sort t) âŸ©
  str (fst m1EqB) sort (mapTerm1 f sort (mapTerm1 (model1Eqâ†’Q-algStr m1EqA) sort t))
    â‰¡âŸ¨ cong (str (fst m1EqB) sort) (funExtâ» (funExtâ» (cong mapTerm1 (
      (Î» sort' â†’ f sort' âˆ˜ model1Eqâ†’Q-algStr m1EqA sort')
        â‰¡âŸ¨ (funExt Î» sort' â†’ funExt Î» t' â†’ ModelQHom1Eqâ†’IsTermQAlgebraHom' m1EqA m1EqB m1EqF sort' t') âŸ©
      (Î» sort' â†’ model1Eqâ†’Q-algStr m1EqB sort' âˆ˜ mapTermQ f sort') âˆ
    )) sort) t) âŸ©
  str (fst m1EqB) sort (mapTerm1 (model1Eqâ†’Q-algStr m1EqB) sort (mapTerm1 (mapTermQ f) sort t)) âˆ
ModelQHom1Eqâ†’IsTermQAlgebraHom' m1EqA m1EqB m1EqF sort (joinFQ t) i =
  mapTermF-ModelQHom1Eqâ†’IsTermQAlgebraHom' m1EqA m1EqB m1EqF sort t i
-- The following all follows from Sethood but there seems to be a de Bruijn error in agda-cubical?
ModelQHom1Eqâ†’IsTermQAlgebraHom'
  m1EqA@(algebra msetA Î±1 , respectsEqA)
  m1EqB@(algebra msetB Î²1 , respectsEqB)
  m1EqF@(algebraHom f f-isalg1) sort (joinFQ-varF t j) i =
  {!idfun
    (Square
      (Î» j â†’ f sort
         (model1Eqâ†’Q-algStr (algebra msetA Î±1 , respectsEqA) sort t))
      (Î» j â†’ model1Eqâ†’Q-algStr (algebra msetB Î²1 , respectsEqB)
         sort (mapTermQ f sort t))
      (Î» i â†’ mapTermF-ModelQHom1Eqâ†’IsTermQAlgebraHom'
         (algebra msetA Î±1 , respectsEqA) (algebra msetB Î²1 , respectsEqB)
         (algebraHom f f-isalg1) sort (varF t) {!i!})
      (Î» i â†’ ModelQHom1Eqâ†’IsTermQAlgebraHom'
         (algebra msetA Î±1 , respectsEqA) (algebra msetB Î²1 , respectsEqB)
         (algebraHom f f-isalg1) sort t i)
    ) (toPathP (snd (msetB sort) _ _ _ _)) i j!}
ModelQHom1Eqâ†’IsTermQAlgebraHom' m1EqA m1EqB@(algebra msetB Î²1 , respectsEqB) m1EqF sort (joinFQ-astF t j) i =
  {!idfun
    (Square
      (Î» j â†’ {!!})
      (Î» j â†’ {!!})
      (Î» i â†’ {!!})
      (Î» i â†’ {!!})
    ) (toPathP (snd (msetB sort) _ _ _ _)) i j!}
ModelQHom1Eqâ†’IsTermQAlgebraHom' m1EqA m1EqB@(algebra msetB Î²1 , respectsEqB) m1EqF sort (byAxiom axiom g j) i =
  {!idfun
    (Square
      (Î» j â†’ {!!})
      (Î» j â†’ {!!})
      (Î» i â†’ {!!})
      (Î» i â†’ {!!})
    ) (toPathP (snd (msetB sort) _ _ _ _)) i j!}
ModelQHom1Eqâ†’IsTermQAlgebraHom' m1EqA m1EqB@(algebra msetB Î²1 , respectsEqB) m1EqF sort (isSetTermQ t1 t2 et et' j k) i =
  {!snd (msetB sort)
    ?
    ?
    ?
    ? j k!}
mapTermF-ModelQHom1Eqâ†’IsTermQAlgebraHom'
  m1EqA@(algebra msetA Î±1 , respectsEqA)
  m1EqB@(algebra msetB Î²1 , respectsEqB)
  m1EqF@(algebraHom f f-isalg1) sort t =
    f sort (Î±F sort (mapTermF (model1Eqâ†’Q-algStr m1EqA) sort t))
      â‰¡âŸ¨ funExtâ» (funExtâ» f-isalgF sort) (mapTermF (model1Eqâ†’Q-algStr m1EqA) sort t) âŸ©
    Î²F sort (mapTermF f sort (mapTermF (model1Eqâ†’Q-algStr m1EqA) sort t))
      â‰¡âŸ¨ cong (Î²F sort) (funExtâ» (funExtâ» (
        (Î» sort' â†’ mapTermF f sort' âˆ˜ mapTermF (model1Eqâ†’Q-algStr m1EqA) sort')
          â‰¡âŸ¨ sym (mapTermF-âˆ˜ f (model1Eqâ†’Q-algStr m1EqA)) âŸ©
        mapTermF (Î» sortâ‚ â†’ f sortâ‚ âˆ˜ model1Eqâ†’Q-algStr (algebra msetA Î±1 , respectsEqA) sortâ‚)
          â‰¡âŸ¨ cong mapTermF (funExt Î» sort' â†’ funExt Î» t' â†’ ModelQHom1Eqâ†’IsTermQAlgebraHom' m1EqA m1EqB m1EqF sort' t') âŸ©
        mapTermF (Î» sortâ‚ â†’ model1Eqâ†’Q-algStr m1EqB sortâ‚ âˆ˜ mapTermQ f sortâ‚)
          â‰¡âŸ¨ mapTermF-âˆ˜ (model1Eqâ†’Q-algStr m1EqB) (mapTermQ f) âŸ©
        (Î» sort' â†’ mapTermF (model1Eqâ†’Q-algStr m1EqB) sort' âˆ˜ mapTermF (mapTermQ f) sort') âˆ
      ) sort) t) âŸ©
    Î²F sort (mapTermF (model1Eqâ†’Q-algStr m1EqB) sort (mapTermF (mapTermQ f) sort t)) âˆ
  where Î±F : IsAlgebra ftrTermF msetA
        Î±F = model1â†’F (algebra msetA Î±1) .fst .str
        Î²F : IsAlgebra ftrTermF msetB
        Î²F = model1â†’F (algebra msetB Î²1) .fst .str
        f-isalgF : IsAlgebraHom ftrTermF (algebra msetA Î±F) (algebra msetB Î²F) f
        f-isalgF = strHom (model1â†’F-hom m1EqF)

{-

  {!!}
    â‰¡âŸ¨ {!!} âŸ©
  {!!}
-}

ModelQHom1Eqâ†’IsTermQAlgebraHom : âˆ€ m1EqA m1EqB â†’ (m1EqF : Model1EqHom m1EqA m1EqB) â†’
      (Î» (sort : Sort) (t : TermQ (mtyp (m1EqA .fst .carrier)) sort)
        â†’ carrierHom m1EqF sort (model1Eqâ†’Q-algStr m1EqA sort t))
      â‰¡
      (Î» (sort : Sort) (t : TermQ (mtyp (m1EqA .fst .carrier)) sort)
        â†’ model1Eqâ†’Q-algStr m1EqB sort (mapTermQ (carrierHom m1EqF) sort t))
ModelQHom1Eqâ†’IsTermQAlgebraHom m1EqA m1EqB m1EqF i sort t =
  ModelQHom1Eqâ†’IsTermQAlgebraHom' m1EqA m1EqB m1EqF sort t i

ModelQHom1Eqâ†’ModelQHom : âˆ€ m1EqA m1EqB â†’ Model1EqHom m1EqA m1EqB â†’ ModelQHom (model1Eqâ†’Q m1EqA) (model1Eqâ†’Q m1EqB)
carrierHom (ModelQHom1Eqâ†’ModelQHom m1EqA m1EqB m1EqF) = carrierHom m1EqF
strHom (ModelQHom1Eqâ†’ModelQHom m1EqA m1EqB m1EqF) = ModelQHom1Eqâ†’IsTermQAlgebraHom m1EqA m1EqB m1EqF

ftrModel1Eqâ†’Q : Functor catModel1Eq catModelQ
F-ob ftrModel1Eqâ†’Q = model1Eqâ†’Q
F-hom ftrModel1Eqâ†’Q {m1EqA} {m1EqB} = ModelQHom1Eqâ†’ModelQHom m1EqA m1EqB
F-id ftrModel1Eqâ†’Q = AlgebraHomâ‰¡ ftrTermQ refl
F-seq ftrModel1Eqâ†’Q f g = AlgebraHomâ‰¡ ftrTermQ refl

---------

-- catModelQ â†’ catModelFEq

ftrModelQQâ†’F : Functor catModelQ catModelF
ftrModelQQâ†’F = EMFunctor monadTermFâ†’Q

modelQâ†’F : ModelQ â†’ ModelF
modelQâ†’F = F-ob ftrModelQQâ†’F

modelQâ†’F-respectsEqTheoryF : (mA : ModelQ) â†’ respectsEqTheoryF (modelQâ†’F mA)
modelQâ†’F-respectsEqTheoryF mA@(algebra msetA Î±Q , isEMA) {sort} axiom f = cong (Î±Q sort) (
  termFâ†’Q sort (mapTermF f sort (lhs axiom))
    â‰¡âŸ¨ sym (funExtâ» (funExtâ» lemma sort) (lhs axiom)) âŸ©
  joinFQ (mapTermF (Î» sort' x â†’ var (f sort' x)) sort (lhs axiom))
    â‰¡âŸ¨ modelQâ†’F-respectsEqTheoryF' âŸ©
  joinFQ (mapTermF (Î» sort' x â†’ var (f sort' x)) sort (rhs axiom))
    â‰¡âŸ¨ funExtâ» (funExtâ» lemma sort) (rhs axiom) âŸ©
  termFâ†’Q sort (mapTermF f sort (rhs axiom)) âˆ
  )
  where modelQâ†’F-respectsEqTheoryF' : joinFQ (mapTermF (Î» sort' x â†’ pureTermQ sort' (f sort' x)) sort (lhs axiom))
                                     â‰¡ joinFQ (mapTermF (Î» sort' x â†’ pureTermQ sort' (f sort' x)) sort (rhs axiom))
        modelQâ†’F-respectsEqTheoryF' = byAxiom axiom (Î» sort' â†’ pureTermQ sort' âˆ˜ f sort')
        lemma : (Î» (sort : Sort) â†’ joinFQ âˆ˜ mapTermF (Î» sort' x â†’ pureTermQ sort' (f sort' x)) sort)
              â‰¡ (Î» (sort : Sort) â†’ termFâ†’Q sort âˆ˜ mapTermF f sort)
        lemma =
          (Î» sort â†’ joinFQ âˆ˜ mapTermF (Î» sort' x â†’ pureTermQ sort' (f sort' x)) sort)
            â‰¡âŸ¨ (funExt Î» sort â†’ cong (joinFQ âˆ˜_) (funExtâ» (mapTermF-âˆ˜ pureTermQ f) sort)) âŸ©
          (Î» sort â†’ joinFQ âˆ˜ mapTermF pureTermQ sort âˆ˜ mapTermF f sort)
            â‰¡âŸ¨ (funExt Î» sort â†’ cong (_âˆ˜ mapTermF f sort) (funExtâ» joinFQ-mapTermF-pureTermQ sort)) âŸ©
          (Î» sort â†’ termFâ†’Q sort âˆ˜ mapTermF f sort) âˆ

ftrModelQQâ†’FEq : Functor catModelQ catModelFEq
ftrModelQQâ†’FEq = ToFullSubcategory catModelQ catModelF respectsEqTheoryF ftrModelQQâ†’F modelQâ†’F-respectsEqTheoryF

modelQâ†’FEq : ModelQ â†’ ModelFEq
modelQâ†’FEq = F-ob ftrModelQQâ†’FEq

---------

{-# TERMINATING #-}
model1Eqâ†’Fâ†’Q-algStr : (m1Eq : Model1Eq)
  â†’ (Î» (sort : Sort) â†’ model1Eqâ†’Q-algStr m1Eq sort âˆ˜ termFâ†’Q sort)
   â‰¡ (Î» (sort : Sort) â†’ model1â†’F-algStr (fst m1Eq) sort)
model1Eqâ†’Fâ†’Q-algStr m1Eq@(algebra msetA Î± , respectsEqTheory1A) i sort (varF x) = x
model1Eqâ†’Fâ†’Q-algStr m1Eq@(algebra msetA Î± , respectsEqTheory1A) i sort (astF t) =
  Î± sort (mapTerm1 (model1Eqâ†’Fâ†’Q-algStr m1Eq i) sort t)

model1Eqâ†’Qâ†’FEq : modelQâ†’FEq âˆ˜ model1Eqâ†’Q â‰¡ model1Eqâ†’FEq
model1Eqâ†’Qâ†’FEq = funExt Î» (m1Eq@(algebra msetA Î± , respectsEqTheory1A)) â†’
  Î£â‰¡Prop isProp-respectsEqTheoryF (
    Î£â‰¡Prop (Î» _ â†’ isPropIsEMAlgebra monadTermF) (congâ‚‚ algebra
      refl
      (model1Eqâ†’Fâ†’Q-algStr m1Eq)
    )
  )

ftrModel1Eqâ†’Qâ†’FEq : funcComp ftrModelQQâ†’FEq ftrModel1Eqâ†’Q â‰¡ ftrModel1Eqâ†’FEq
ftrModel1Eqâ†’Qâ†’FEq = Functorâ‰¡
  (funExtâ» model1Eqâ†’Qâ†’FEq)
  Î» f â†’ AlgebraHomPathP ftrTermF refl

{-# TERMINATING #-}
modelQâ†’1Eqâ†’Q-algStr : (mA : ModelQ)
  â†’ model1Eqâ†’Q-algStr (modelFEqâ†’1Eq (modelQâ†’FEq mA))
   â‰¡ mA .fst .str
modelQâ†’1Eqâ†’Q-algStr mA = foldModelQ-uniq2 (mA .fst .carrier) mA
  (algebraHom
    (model1Eqâ†’Q-algStr (modelFEqâ†’1Eq (modelQâ†’FEq mA)))
    ( model1Eqâ†’Q-algStr-joinTermQ (modelFEqâ†’1Eq (modelQâ†’FEq mA))
    âˆ™ funExt Î» sort â†’ cong (_âˆ˜ mapTermQ (model1Eqâ†’Q-algStr (modelFEqâ†’1Eq (modelQâ†’FEq mA))) sort)
      (funExtâ» (modelQâ†’1Eqâ†’Q-algStr mA) sort) -- induction
    )
  )
  (algebraHom
    (Î» a â†’ mA .fst .str a)
    (mA .snd .str-Î¼)
  )
  (sym (mA .snd .str-Î·))

modelQâ†’FEqâ†’1Eqâ†’Q : model1Eqâ†’Q âˆ˜ modelFEqâ†’1Eq âˆ˜ modelQâ†’FEq â‰¡ idfun ModelQ
modelQâ†’FEqâ†’1Eqâ†’Q = funExt Î» mA â†’
  Î£â‰¡Prop (Î» _ â†’ isPropIsEMAlgebra monadTermQ) (congâ‚‚ algebra
    refl
    (modelQâ†’1Eqâ†’Q-algStr mA)
  )

ftrModelQQâ†’FEqâ†’1Eqâ†’Q : funcComp (funcComp ftrModel1Eqâ†’Q ftrModelFEqâ†’1Eq) ftrModelQQâ†’FEq â‰¡ funcId catModelQ
ftrModelQQâ†’FEqâ†’1Eqâ†’Q = Functorâ‰¡
  (funExtâ» modelQâ†’FEqâ†’1Eqâ†’Q)
  Î» f â†’ AlgebraHomPathP ftrTermQ refl

---------

isoftrModelFEqâ‰…Q : P.PrecatIso (CatPrecategory â„“-zero â„“-zero) catModelFEq catModelQ
Pâ‰….mor isoftrModelFEqâ‰…Q = funcComp ftrModel1Eqâ†’Q ftrModelFEqâ†’1Eq
Pâ‰….inv isoftrModelFEqâ‰…Q = ftrModelQQâ†’FEq
Pâ‰….sec isoftrModelFEqâ‰…Q = ftrModelQQâ†’FEqâ†’1Eqâ†’Q
Pâ‰….ret isoftrModelFEqâ‰…Q =
  funcComp ftrModelQQâ†’FEq (funcComp ftrModel1Eqâ†’Q ftrModelFEqâ†’1Eq)
    â‰¡âŸ¨ F-assoc âŸ©
  funcComp (funcComp ftrModelQQâ†’FEq ftrModel1Eqâ†’Q) ftrModelFEqâ†’1Eq
    â‰¡âŸ¨ cong (Î» F â†’ funcComp F ftrModelFEqâ†’1Eq) ftrModel1Eqâ†’Qâ†’FEq âŸ©
  funcComp ftrModel1Eqâ†’FEq ftrModelFEqâ†’1Eq
    â‰¡âŸ¨ ftrModelFEqâ†’1Eqâ†’FEq âŸ©
  funcId catModelFEq âˆ

isoftrModel1Eqâ‰…Q : P.PrecatIso (CatPrecategory â„“-zero â„“-zero) catModel1Eq catModelQ
Pâ‰….mor isoftrModel1Eqâ‰…Q = ftrModel1Eqâ†’Q
Pâ‰….inv isoftrModel1Eqâ‰…Q = funcComp ftrModelFEqâ†’1Eq ftrModelQQâ†’FEq
Pâ‰….sec isoftrModel1Eqâ‰…Q =
  funcComp ftrModel1Eqâ†’Q (funcComp ftrModelFEqâ†’1Eq ftrModelQQâ†’FEq)
    â‰¡âŸ¨ F-assoc âŸ©
  funcComp (funcComp ftrModel1Eqâ†’Q ftrModelFEqâ†’1Eq) ftrModelQQâ†’FEq
    â‰¡âŸ¨ ftrModelQQâ†’FEqâ†’1Eqâ†’Q âŸ©
  funcId catModelQ âˆ
Pâ‰….ret isoftrModel1Eqâ‰…Q =
  funcComp (funcComp ftrModelFEqâ†’1Eq ftrModelQQâ†’FEq) ftrModel1Eqâ†’Q
    â‰¡âŸ¨ sym F-assoc âŸ©
  funcComp ftrModelFEqâ†’1Eq (funcComp ftrModelQQâ†’FEq ftrModel1Eqâ†’Q)
    â‰¡âŸ¨ cong (funcComp ftrModelFEqâ†’1Eq) ftrModel1Eqâ†’Qâ†’FEq âŸ©
  funcComp ftrModelFEqâ†’1Eq ftrModel1Eqâ†’FEq
    â‰¡âŸ¨ ftrModel1Eqâ†’FEqâ†’1Eq âŸ©
  funcId catModel1Eq âˆ

-----------

-- Syntax object
module _ where

  mSyntax : ModelQ
  mSyntax = F-ob ftrFreeModelQ msetEmpty

  open NaturalBijection

  isInitial-mSyntax : isInitial catModelQ mSyntax
  isInitial-mSyntax = isLeftAdjointâ†’preservesInitial
    {C = catMSet}
    {D = catModelQ}
    ftrFreeModelQ
    (ftrForgetModelQ , emAdjunction monadTermQ)
    msetEmpty
    isInitial-msetEmpty

  
