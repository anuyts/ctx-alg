{-# OPTIONS --cubical --type-in-type #-}

open import Cubical.Foundations.Prelude
open import Cubical.Foundations.HLevels
open import Cubical.Foundations.Function
open import Cubical.Foundations.Univalence
open import Cubical.Foundations.Transport
open import Cubical.Foundations.Isomorphism renaming (Iso to _‚âÖ_)
open import Cubical.Data.List hiding ([_])
open import Cubical.Data.List.Properties
open import Cubical.Data.List.FinData renaming (lookup to _!_)
open import Cubical.Data.List.Dependent renaming (lookupP to _!P_)
open import Cubical.Data.Prod
open import Cubical.Data.W.Indexed
open import Cubical.Data.FinData
open import Cubical.Data.Sum
open import Cubical.Data.Sum as ‚äé
open import Cubical.Data.Empty
open import Cubical.Data.Nat
open import Cubical.Data.Sigma.Properties
open import Cubical.Foundations.Structure
open import Cubical.Categories.Category
open import Cubical.Categories.Category.Precategory hiding (_[_,_] ; seq')
open import Cubical.Categories.Functor renaming (ùüô‚ü®_‚ü© to ftrId)
open import Cubical.Categories.Instances.Sets
open import Cubical.Categories.Instances.Categories
open import Cubical.Categories.Constructions.Product
open import Cubical.Categories.Monad.Base
open import Cubical.Categories.NaturalTransformation.Base
open import Cubical.Categories.Instances.FunctorAlgebras
open import Cubical.Categories.Instances.EilenbergMoore
open import Cubical.Categories.Adjoint
open import Cubical.Categories.Limits.Initial

open import Mat.Signature
open import Mat.Free.Presentation

-- Terms of the free MAT generated by a free MAT presentation
module Mat.Free.Term where

module TermF {matsig : MatSignature} (fmat : FreeMat matsig) where
    open _‚âÖ_
    open Category renaming (_‚àò_ to _‚äö_)
    open Functor
    open NatTrans
    open MatSignature matsig
    open FreeMat fmat
    open Algebra renaming (str to algStr)
    open AlgebraHom
    open IsEMAlgebra
    open NaturalBijection
    open _‚ä£_

    -- Free syntax monad
    data TermF (X : MType) : MType
    isSetTermF : (msetX : MSet) (sortOut : Sort) ‚Üí isSet (TermF (mtyp msetX) sortOut)

    -- TermF acting on MSets
    msetTermF : MSet ‚Üí MSet
    fst (msetTermF msetX sortOut) = TermF (mtyp msetX) sortOut
    snd (msetTermF msetX sortOut) = isSetTermF msetX sortOut

    data TermF X where
      -- the primes are to signify that the sort is implicit.
      varF' : ‚àÄ {sortOut} ‚Üí X sortOut ‚Üí TermF X sortOut
      join1F' : ‚àÄ {sortOut} ‚Üí Term1 (TermF X) sortOut ‚Üí TermF X sortOut

    varF : ‚àÄ {X} ‚Üí (X ‚ÜíM TermF X)
    varF sort = varF'

    join1F : ‚àÄ {X} ‚Üí (Term1 (TermF X) ‚ÜíM TermF X)
    join1F sort = join1F'

    arvarF : ‚àÄ {arity : Arity} ‚Üí (m : Fin (length arity)) ‚Üí TermF (mtyp (arity2mset arity)) (arity ! m)
    arvarF m = varF' (m , refl)
    pattern _$1_ o args = join1F' (term1 o args)
    infixr 4 _$1_

    -- TermF is really an IW type
    module _ where
      RepTermF : (X : MType) ‚Üí MType
      RepTermF X sortOut =
        IW (Œª sort ‚Üí X sort ‚äé Operation sort)
          (Œª sort ‚Üí ‚äé.elim (Œª v ‚Üí ‚ä•) Œª o ‚Üí Fin (length (arity o)))
          (Œª sort ‚Üí ‚äé.elim (Œª v ()) (Œª o p ‚Üí arity o ! p))
          sortOut

      {-# TERMINATING #-}
      toRepTermF : (X : MType) (sortOut : Sort) ‚Üí TermF X sortOut ‚Üí RepTermF X sortOut
      toRepTermF X sortOut (varF' v) = node (inl v) (Œª ())
      toRepTermF X sortOut (o $1 args) = node (inr o) Œª p ‚Üí mapOverIdfun (toRepTermF X) (arity o) args !P p

      {-# TERMINATING #-}
      fromRepTermF : (X : MType) (sortOut : Sort) ‚Üí RepTermF X sortOut ‚Üí TermF X sortOut
      fromRepTermF X sortOut (node (inl v) u) = varF' v
      fromRepTermF X sortOut (node (inr o) args) =
        o $1 mapOverIdfun (fromRepTermF X) (arity o) (tabulateOverLookup (arity o) args)

      {-# TERMINATING #-}
      fromToRepTermF : (X : MType) (sortOut : Sort) (t : TermF X sortOut)
        ‚Üí fromRepTermF X sortOut (toRepTermF X sortOut t) ‚â° t
      fromToRepTermF X sortOut (varF' v) = refl
      fromToRepTermF X sortOut (join1F' (term1 o args)) =
        cong join1F' (cong (term1 o) (
          mapOverIdfun (fromRepTermF X) (arity o) (tabulateOverLookup (arity o) (_!P_ (mapOverIdfun (toRepTermF X) (arity o) args)))
            ‚â°‚ü® cong (mapOverIdfun _ _) (tabulateOverLookup-lookupP (mapOverIdfun (toRepTermF X) (arity o) args)) ‚ü©
          mapOverIdfun (fromRepTermF X) (arity o) (mapOverIdfun (toRepTermF X) (arity o) args)
            ‚â°‚ü® sym (mapOverIdfun-‚àò (fromRepTermF X) (toRepTermF X) (arity o)) ‚â°$ args ‚ü©
          mapOverIdfun (Œª a ‚Üí fromRepTermF X a ‚àò toRepTermF X a) (arity o) args
            ‚â°‚ü® (cong mapOverIdfun (funExt Œª sort ‚Üí funExt Œª t ‚Üí fromToRepTermF X sort t) ‚â°$ arity o) ‚â°$ args ‚ü©
          mapOverIdfun (Œª x x‚ÇÅ ‚Üí x‚ÇÅ) (arity o) args
            ‚â°‚ü® mapOverIdfun-idfun (arity o) ‚â°$ args ‚ü©
          args ‚àé
        ))

    {-# TERMINATING #-} -- this pragma is ignored if I put this definition also in the module :-O
    toFromRepTermF : (X : MType) (sortOut : Sort) (rt : RepTermF X sortOut)
        ‚Üí toRepTermF X sortOut (fromRepTermF X sortOut rt) ‚â° rt
    toFromRepTermF X sortOut (node (inl v) u) = cong (node (inl v)) (funExt (Œª ()))
    toFromRepTermF X sortOut (node (inr o) args) = cong {B = Œª _ ‚Üí RepTermF X sortOut} (node (inr o)) (
          _!P_ (mapOverIdfun (toRepTermF X) (arity o) (mapOverIdfun (fromRepTermF X) (arity o) (tabulateOverLookup (arity o) args)))
            ‚â°‚ü® cong _!P_ (sym (mapOverIdfun-‚àò
                 (toRepTermF X)
                 (fromRepTermF X)
                 (arity o)
                 ‚â°$ (tabulateOverLookup (arity o) args)
               )) ‚ü©
          _!P_ (mapOverIdfun (Œª sort ‚Üí toRepTermF X sort ‚àò fromRepTermF X sort) (arity o) (tabulateOverLookup (arity o) args))
            ‚â°‚ü® cong _!P_
                 ((cong mapOverIdfun (funExt Œª sort ‚Üí funExt Œª t ‚Üí toFromRepTermF X sort t)
                   ‚â°$ arity o)
                   ‚â°$ tabulateOverLookup (arity o) args) ‚ü©
          _!P_ (mapOverIdfun (Œª x x‚ÇÅ ‚Üí x‚ÇÅ) (arity o) (tabulateOverLookup (arity o) args))
            ‚â°‚ü® cong (_!P_ {B = RepTermF X}) (mapOverIdfun-idfun (arity o) ‚â°$ tabulateOverLookup (arity o) args) ‚ü©
          _!P_ (tabulateOverLookup (arity o) args)
            ‚â°‚ü® lookupP-tabulateOverLookup (RepTermF X) (arity o) args ‚ü©
          args ‚àé
        )

    module _ where
      isoRepTermF : (X : MType) (sortOut : Sort) ‚Üí TermF X sortOut ‚âÖ RepTermF X sortOut
      fun (isoRepTermF X sortOut) = toRepTermF X sortOut
      inv (isoRepTermF X sortOut) = fromRepTermF X sortOut
      rightInv (isoRepTermF X sortOut) = toFromRepTermF X sortOut
      leftInv (isoRepTermF X sortOut) = fromToRepTermF X sortOut

      --pathRepTermF : (X : MType) (sortOut : Sort) ‚Üí TermF X sortOut ‚â° RepTermF X sortOut
      --pathRepTermF X sortOut = ua (isoToEquiv (isoRepTermF X sortOut))

      isSetRepTermF : (msetX : MSet) (sortOut : Sort) ‚Üí isSet (RepTermF (mtyp msetX) sortOut)
      isSetRepTermF msetX sortOut = isOfHLevelSuc-IW 1 (Œª sort ‚Üí isSet‚äé (str (msetX sort)) isSetOperation) sortOut

    isSetTermF msetX sortOut = isOfHLevelRetractFromIso 2 (isoRepTermF (mtyp msetX) sortOut) (isSetRepTermF msetX sortOut)

    -- components of TermF as a functor
    {-# TERMINATING #-}
    mapTermF : ‚àÄ {X Y} ‚Üí (X ‚ÜíM Y) ‚Üí (TermF X ‚ÜíM TermF Y)
    mapTermF f sort (varF' x) = varF' (f sort x)
    mapTermF f sort (join1F' t) = join1F' (mapTerm1 (mapTermF f) sort t)

    {-# TERMINATING #-}
    mapTermF-id : ‚àÄ {X} ‚Üí mapTermF (idfunM X) ‚â° idfunM (TermF X)
    mapTermF-id {X} i sort (varF' x) = varF' x
    mapTermF-id {X} i sort (join1F' t) = (
        join1F' (mapTerm1 (mapTermF (idfunM X)) sort t)
          ‚â°‚ü® cong join1F' ((cong mapTerm1 mapTermF-id ‚â°$ sort) ‚â°$ t) ‚ü©
        join1F' (mapTerm1 (idfunM (TermF X)) sort t)
          ‚â°‚ü® cong join1F' ((mapTerm1-id ‚â°$ sort) ‚â°$ t) ‚ü©
        join1F' t ‚àé
      ) i

    {-# TERMINATING #-}
    mapTermF-‚àò : ‚àÄ {X Y Z : MType} ‚Üí (g : Y ‚ÜíM Z) ‚Üí (f : X ‚ÜíM Y) ‚Üí
      mapTermF (g ‚àòM f) ‚â° mapTermF g ‚àòM mapTermF f
    mapTermF-‚àò g f i sort (varF' x) = varF' (g sort (f sort x))
    mapTermF-‚àò g f i sort (join1F' t) = (
        join1F' (mapTerm1 (mapTermF (g ‚àòM f)) sort t)
          ‚â°‚ü® cong join1F' ((cong mapTerm1 (mapTermF-‚àò g f) ‚â°$ sort) ‚â°$ t) ‚ü©
        join1F' (mapTerm1 (mapTermF g ‚àòM mapTermF f) sort t)
          ‚â°‚ü® cong join1F' ((mapTerm1-‚àò (mapTermF g) (mapTermF f) ‚â°$ sort) ‚â°$ t) ‚ü©
        join1F' ((mapTerm1 (mapTermF g) ‚àòM mapTerm1 (mapTermF f)) sort t) ‚àé
      ) i

    -- TermF as a functor on catMSet
    ftrTermF : Functor catMSet catMSet
    F-ob ftrTermF = msetTermF
    F-hom ftrTermF = mapTermF
    F-id ftrTermF = mapTermF-id
    F-seq ftrTermF f g = mapTermF-‚àò g f

    -- components of TermF as a monad

    pureTermF : ‚àÄ {X} ‚Üí (X ‚ÜíM TermF X)
    pureTermF sort = varF'

    Œ∑TermF : NatTrans (ftrId catMSet) ftrTermF
    N-ob Œ∑TermF msetX sortOut = varF'
    N-hom Œ∑TermF {msetX} {msetY} f = refl

    {-# TERMINATING #-}
    joinTermF : ‚àÄ {X} sort ‚Üí TermF (TermF X) sort ‚Üí TermF X sort
    joinTermF sort (varF' t) = t
    joinTermF sort (join1F' t) = join1F' (mapTerm1 joinTermF sort t)

    {-# TERMINATING #-}
    joinTermF-nat : ‚àÄ {X Y : MType} f sort ‚Üí (t : TermF (TermF X) sort)
      ‚Üí joinTermF {X = Y} sort (mapTermF (mapTermF f) sort t) ‚â° mapTermF f sort (joinTermF sort t)
    joinTermF-nat f sort (varF' t) = refl
    joinTermF-nat f sort (join1F' t) = cong join1F' (((
        (Œª sort ‚Üí mapTerm1 joinTermF sort ‚àò mapTerm1 (mapTermF (mapTermF f)) sort)
          ‚â°‚ü® sym (mapTerm1-‚àò joinTermF (mapTermF (mapTermF f))) ‚ü©
        mapTerm1 (Œª sort‚ÇÅ ‚Üí joinTermF sort‚ÇÅ ‚àò mapTermF (mapTermF f) sort‚ÇÅ)
          ‚â°‚ü® cong mapTerm1 (funExt Œª sort ‚Üí funExt Œª t ‚Üí joinTermF-nat f sort t) ‚ü©
        mapTerm1 (Œª x x‚ÇÅ ‚Üí mapTermF f x (joinTermF x x‚ÇÅ))
          ‚â°‚ü® mapTerm1-‚àò (mapTermF f) joinTermF ‚ü©
        (Œª sort ‚Üí mapTerm1 (mapTermF f) sort ‚àò mapTerm1 joinTermF sort) ‚àé
      ) ‚â°$ sort) ‚â°$ t)

    ŒºTermF : NatTrans (funcComp ftrTermF ftrTermF) ftrTermF
    N-ob ŒºTermF msetX = joinTermF
    N-hom ŒºTermF {msetX} {msetY} f = funExt Œª sort ‚Üí funExt Œª t ‚Üí joinTermF-nat f sort t

    open IsMonad

    -- TermF is a monad
    {-# TERMINATING #-}
    ismonadTermF : IsMonad ftrTermF
    Œ∑ ismonadTermF = Œ∑TermF
    Œº ismonadTermF = ŒºTermF
    idl-Œº ismonadTermF = makeNatTransPathP (Œª i ‚Üí F-rUnit i) (Œª i ‚Üí ftrTermF) refl
    idr-Œº ismonadTermF = makeNatTransPathP (Œª i ‚Üí F-lUnit i) (Œª i ‚Üí ftrTermF) lemma
      where lemma : (Œª msetX sort t ‚Üí joinTermF sort (mapTermF (Œª sortOut ‚Üí varF') sort t)) ‚â°
                    (Œª msetX sort t ‚Üí t)
            lemma i msetX sort (varF' x) = varF' x
            lemma i msetX sort (join1F' t) = cong join1F' (((
                (Œª sort' ‚Üí mapTerm1 joinTermF sort' ‚àò mapTerm1 (mapTermF pureTermF) sort')
                  ‚â°‚ü® sym (mapTerm1-‚àò joinTermF (mapTermF pureTermF)) ‚ü©
                mapTerm1 (Œª sort‚ÇÅ ‚Üí joinTermF sort‚ÇÅ ‚àò mapTermF pureTermF sort‚ÇÅ)
                  ‚â°‚ü® cong mapTerm1 (lemma ‚â°$ msetX) ‚ü©
                mapTerm1 (Œª a x ‚Üí x)
                  ‚â°‚ü® mapTerm1-id ‚ü©
                (Œª sort' t ‚Üí t) ‚àé
              ) ‚â°$ sort) ‚â°$ t) i
    assoc-Œº ismonadTermF = makeNatTransPathP (Œª i ‚Üí F-assoc i) (Œª i ‚Üí ftrTermF) lemma
      where lemma : (Œª msetX sort t ‚Üí joinTermF sort (mapTermF joinTermF sort t)) ‚â°
                    (Œª msetX sort t ‚Üí joinTermF sort (joinTermF sort t))
            lemma i msetX sort (varF' ttx) = joinTermF sort ttx
            lemma i msetX sort (join1F' t) = cong join1F' (((
                (Œª sort' ‚Üí mapTerm1 joinTermF sort' ‚àò mapTerm1 (mapTermF joinTermF) sort')
                  ‚â°‚ü® sym (mapTerm1-‚àò joinTermF (mapTermF joinTermF)) ‚ü©
                mapTerm1 (Œª sort‚ÇÅ ‚Üí joinTermF sort‚ÇÅ ‚àò mapTermF joinTermF sort‚ÇÅ)
                  ‚â°‚ü® cong mapTerm1 (lemma ‚â°$ msetX) ‚ü©
                mapTerm1 (Œª a x ‚Üí joinTermF a (joinTermF a x))
                  ‚â°‚ü® mapTerm1-‚àò joinTermF joinTermF ‚ü©
                (Œª sort' ‚Üí mapTerm1 joinTermF sort' ‚àò mapTerm1 joinTermF sort') ‚àé
              ) ‚â°$ sort) ‚â°$ t) i
            --join1F' (term1 o Œª p ‚Üí lemma i msetX (arity o ! p) (args p))

    monadTermF : Monad catMSet
    monadTermF = ftrTermF , ismonadTermF

    SyntaxF : MType
    SyntaxF = TermF (mtyp msetEmpty)

    msetSyntaxF : MSet
    msetSyntaxF = msetTermF msetEmpty

module _ {matsig : MatSignature} (fmat1 fmat2 : FreeMat matsig) where

  open MatSignature matsig
  open FreeMat
  open Term1
  open TermF

  {-# TERMINATING #-}
  opmapTermF : OpHom fmat1 fmat2 ‚Üí ‚àÄ {X} sort ‚Üí TermF fmat1 X sort ‚Üí TermF fmat2 X sort
  opmapTermF ophom sort (varF' x) = varF' x
  opmapTermF ophom sort (join1F' t) = join1F' (opmapTerm1 fmat1 fmat2 ophom sort (mapTerm1 fmat1 (opmapTermF ophom) sort t))
